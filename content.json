{"pages":[{"title":"","text":"","link":"/about/index.html"}],"posts":[{"title":"RESTful API 设计参考文献收集","text":"RESTful API 设计参考文献列表，可帮助你更加彻底的了解REST风格的接口设计。RESTful 介绍及设计思路Principles of good RESTful API Design（译：好 RESTful API 的设计原则 ）简单易懂，条理清晰，推荐Best Practices for Designing a Pragmatic RESTful API（译：RESTful 最佳实践 译文2）有实际的案例 EnchantHTTP API Design Guide（译：HTTP API 设计指南）Some REST best practices理解 RESTful 架构 - 阮一峰 简单了解什么是 RESTFulRESTful API 设计指南 - 阮一峰Restful API 的设计规范 实战经验的总结，具有较强的启发意义撰写安全合格的REST API 利用好 HTTP 协议所具备的特征Web 服务编程，REST 与 SOAP REST 与传统的面向服务的接口设计的区别，启发性强最佳实践：更好的设计你的 REST API 了解 REST 实现缓存的过程Thoughts on RESTful API DesignREST API Tutorial 全方位介绍 RESTHTTP 接口设计指北Web API Design 接口就是开发人员提供的“界面”，用户体验在接口设计上同样重要，在线查看 2012 版、2013 版架构风格与基于网络应用软件的架构设计 原汁原味的博士论文，由李锟翻译，有经验的同学可以挑战一下Microsoft REST API Guidelines 微软官方的 REST API 设计指南，值得参考RESTful API 设计最佳实践知识碎片理解 HTTP 幂等性 讲得很清楚，推荐浅析远程过程调用 RPC 告诉你什么是 RPChttpstatuses 一眼看完所有常用的 HTTP 状态码，还可以看详细含义List of HTTP status codes From WikipediaHTTP Status Codes.aspx) From MSDN MicrosoftList of HTTP header fieldsjson-api 对 API 应该如何利用好 JSON 的一些建议介绍 JSON 无论如何都应该读一遍decision-graph.svg 一张大图展示整个 REST API 的验证过程，及各种状态码出现的时机书籍RESTful Web APIs 较新的一本书，对 REST 做了很多系统性的总结，尤其对“超媒体”作了详细的介绍Jersey-2.x-User-Guide（译：Jersey 2.x 用户指南）译者也提供了入门简易教程 REST 实战以及综合实例 RestDemo（注：读者需要 Java 基础）REST CookBook 基础介绍构建 RESTful API架构风格与基于网络应用软件的架构设计（中文修订版）例子Github API v3 被很多人参考和引用，比如对分页的处理方法、接口版本的设计等等Mailgun Documentation 邮件服务 REST APIEnchant REST APICoinbase API 设计的挺好的，包括官网提供的接口客户端，都是具有参考意义的OpenNMS Wiki ReST APIREST API 使用详解 Lean Cloud 中讲解 REST API 的使用，还集成 Swagger UI 在线调试工具，点击查看。关于例子，实在是太多了，在有时间的时候，多观察别人的设计，有利于写出好的 API。调试工具DHC (aka Dev HTTP Client) Chrome 插件，简单易用，可分类管理，界面友好。也很多人推荐 PostmanFiddler2 抓包，捕捉每一次 REST 请求和响应的详细内容文档制作slate 创建的 API 文档很好看，也很实用，三列式，目录、调用说明和代码示例同屏滚动显示。i5ting_ztree_toc API 把 Markdown 文档生成简单的 HTML API","link":"/mTBBU3/"},{"title":"从零开始的Hexo博客搭建教程（四）：图床","text":"🖼写文章从选用一个好图床开始！一步一步按照教程挑选适合自己的图床服务吧！结合一些图床上传工具使得写文章事半功倍！（虽然这一辑教程和Hexo没太大关系啦）🎀多图预警！图床七牛对象存储大概是非常常用的对象存储了吧。很多人推荐使用七牛云存储作为图床(高效、快速、有保障)优点：对于认证用户，七牛云存储提供免费的存储空间 10GB，每月下载流量 10GB，每月 PUT/DELETE 10 万次请求，每月 GET 100 万次请求。缺点：HTTPS 域名产生的用量不计入免费额度只有 30 天的测试域名，七牛融合 CDN 测试域名（clouddn.com/qiniucdn.com/qiniudn.com/qnssl.com/qbox.me 结尾），每个域名每日限总流量 10GB，每个测试域名自创建起 30 个自然日后系统会自动销毁，仅供测试使用。到期后就只能自己绑定域名了，如果你的博客托管于 Github/Coding等服务上，并且手中没有闲置的已备案域名，也就意味着你要跳过七牛这一选项了。1七牛对象存储 &lt;= 需要域名的备案号+公安备案号 &lt;= 需要购买主机整个操作周期至少10天左右。图床迁移很麻烦，无法批量下载。STEP1: 注册账号并实名认证登录 七牛开发者平台，如果没有注册账号请先注册成为体验用户。体验用户无法使用任何服务，请先前往 个人中心 - 个人信息 实名认证。认证需提供 真实姓名、身份证号、身份证正反两面照片 等信息，3个工作日内人工审核完毕。STEP2: 新建存储空间打开 对象存储 - 新建存储空间 即可创建新的Bucket。在 内容管理 栏目中可以上传、下载、访问、修改资源等操作。记下 Bucket名(即你创建的存储空间的名字)、外链默认域名。打开 个人中心 - 密钥设置，记下 AccessKey/SecretKey，接下来会用到。工具推荐PicGo: 跨平台图床神器【强烈推荐】基于 electron-vue 的开源跨平台图片上传工具，简化上传图片的繁杂操作，支持一键拖拽、剪贴板上传，功能强大，简单易用。PicGo在上传图片之后自动会将图片链接复制到你的剪贴板里，可选5种复制的链接格式。支持macOS、windows 64位（&gt;= v1.3.1），linux（&gt;= v1.6.0）。Mac 上一款很不错的小工具应用 iPic 免费版本并不支持七牛图床，而PicGo v2.0.3 目前支持 SM.MS、腾讯云COS、微博图床、GitHub、七牛、Imgur、阿里云COS、又拍云等8种常用图床，其他图床服务可通过手写插件添加。需要注意的是，想要使用PicGo 2.0的插件系统，需要先行安装Node.js环境，因为PicGo的插件安装依赖npm。支持快捷键command+shift+p（macOS）或者control+shift+p（windows\\linux）用以支持快捷上传剪贴板里的图片（第一张）。 PicGo支持自定义快捷键，使用方法见配置手册。下载地址github.com/Molunerfinn…注意：mac 系统选择 dmg 下载，windwos 选择 .exe系统，如果不是下载安装包，想看源码的话，可以选择 git clone https://github.com/Molunerfinn/PicGo.git 克隆到本地使用Github作为图床的配置https://www.jianshu.com/p/2756724a5deeVSCode的PicGo插件vs-picgo在PicGo-Core发布不久，就有人根据PicGo-Core的API编写了VSCode版的PicGo插件。使用起来也非常方便：支持 截图上传、文件浏览器选择上传、输入文件路径上传。配置项与PicGo的图床的配置项基本保持一致。在VSCode插件栏搜索PicGo即可下载安装与体验！MPic: Windows下的七牛图床上传小工具支持 拖拽上传、截图上传、剪贴板图片上传。下载地址MPic-图床神器Mpic如何设置账号打开Mpic，点击“设置账号”将七牛对应信息填入面板，没有七牛账号请查看本文上方的七牛对象存储教程空间名称： 七牛存储文件的空间名（就是你用于存储文件的文件夹名字，如下图我的）AccessKey： 点击七牛“个人面板”，“密钥管理”中即可看到AccessKeySecretKey： 点击七牛“个人面板”，“密钥管理”中即可看到 SecretKey域名： 存储空间对应的域名，如果存储空间绑定了自己的域名就填写自己的域名设置链接格式和上传方式因为使用图床的目的是为了方便Markdown写作，所以肯定要最终生成的连接是Markdown的图片链接格式。操作方式：在右下角的Mpic图标上，点击右键，然后按照图示勾选Markdown。截图上传：右键单击右下角Mpic图标，把关闭截图自动上传前面的勾去掉，如果没有的勾的话，就保持原样不动。复制上传：和截图上传操作类似，可以直接复制图片上传，我用的不多，因为这样可能会造成一些混乱。有需要的话，可以自行开启。📘《从零开始的Hexo博客搭建教程》系列文章：从零开始的Hexo博客搭建教程（一）：开始从零开始的Hexo博客搭建教程（二）：主题从零开始的Hexo博客搭建教程（三）：SEO优化从零开始的Hexo博客搭建教程（四）：图床从零开始的Hexo博客搭建教程（五）：文章发布从零开始的Hexo博客搭建教程（六）：插件从零开始的Hexo博客搭建教程（七）：遇到的坑","link":"/JjDMWM/"},{"title":"从零开始的Hexo博客搭建教程（五）：文章发布","text":"📑 本篇着重详细介绍如何发布文章。以及发布文章的各种姿势。📘《从零开始的Hexo博客搭建教程》系列文章：从零开始的Hexo博客搭建教程（一）：开始从零开始的Hexo博客搭建教程（二）：主题从零开始的Hexo博客搭建教程（三）：SEO优化从零开始的Hexo博客搭建教程（四）：图床从零开始的Hexo博客搭建教程（五）：文章发布从零开始的Hexo博客搭建教程（六）：插件从零开始的Hexo博客搭建教程（七）：遇到的坑","link":"/1eC0kV/"},{"title":"从零开始的Hexo博客搭建教程（七）：遇到的坑","text":"✨《从零开始的 Hexo 博客搭建教程(how-to-build-hexo-blog)》终于到了第七辑啦！本文用于 收集本人在使用 Hexo 的过程中出现的 各种坑及解决方法。如果你有更好的解决方法或遇过的坑，欢迎在评论区分享喔 ο(=•ω ＜=)ρ⌒☆Template render error问题描述在使用 hexo g 生成文章的时候，控制台报错如下:123FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 12, Column 17]expected variable end出现原因当文章中有 }} 或 EJS 模板语法，且未被代码块包含时，解析会出现问题。解决方法12{% raw %}放到代码块中就OK啦注意: 用单反引号包围还是会引发BUG，请使用三反引号包围。Sitemap.xml 出现错误问题描述解决方法请勿使文章名或 md 文件名包含 &amp; 符号 导致 hexo 文章链接中也包含该符号。去除后再重新生成即可恢复正常。ERROR Deployer not found: git解决方法执行 npm install hexo-deployer-git --save 即可之后请一步一步配置📘《从零开始的Hexo博客搭建教程》系列文章：从零开始的Hexo博客搭建教程（一）：开始从零开始的Hexo博客搭建教程（二）：主题从零开始的Hexo博客搭建教程（三）：SEO优化从零开始的Hexo博客搭建教程（四）：图床从零开始的Hexo博客搭建教程（五）：文章发布从零开始的Hexo博客搭建教程（六）：插件从零开始的Hexo博客搭建教程（七）：遇到的坑","link":"/A-fgp4/"},{"title":"从零开始的Hexo博客搭建教程（一）：开始","text":"🎂 开始你的 Hexo 之旅Why Hexo?基础搭配：Git + Github Pages + Hexo优点免费 - GitHub快速 - Node 运行环境、前端个人站点首选简洁 - MarkDown轻量 - 全部静态文件支持导入 WordPress 等博客不足更换电脑不变 - 需重新安装环境静态博客 - 后期不便于维护多媒体管理较难Get Started安装安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：Node.jsGit如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。1$ npm install -g hexo-cli安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install配置您可以在 _config.yml 中修改大部分的配置。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151# Hexo Configuration Hexo配置文件## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# 网站信息#标题title: 博客标题#副标题subtitle: 博客副标题#网站描述description: 博客简介，涉及SEO#作者昵称author: gylidian#网站语言，默认英语，设置简体汉语language: zh-Hans#时区，默认电脑时区#timezone: timezone: Asia/Shanghai# 网址设置#如果网站是放在子目录中，将url设置成'http://yoursite.com/child'，将root设置成'/child/'## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#网址url: http://www.nuist.today#网站根目录。如果网站是放在子目录中，将root设置成'子目录名'root: /#文章链接地址格式 。即文章存放的目录。permalink: :title/permalink_defaults:# 目录设置#资源文件夹，放在里面的文件会上传到github中source_dir: source#公共文件夹，存放生成的静态文件public_dir: public#标签文件夹，默认是tags。实际存放在source/tags中。tag_dir: tagsrss_dir: rss#档案文件夹，默认是archives。archive_dir: archives#分类文件夹，默认是categories。实际存放在source/categories中。category_dir: categories#代码文件夹，默认是downloads/codecode_dir: downloads/code#国际化文件夹，默认跟language相同i18n_dir: :lang#不需要渲染的文件夹或文件夹,放在[]中# 这两个文件是百度和google的站长验证文件，不能渲染，否则会改变内容，不能验证过skip_render: [baidu_verify_R9MZjdMkXT.html, google0f8fac7da2b48ef8.html, README.md, 模板.md]# 写作选项# 新建博文（帖子）的默认名称# File name of new postsnew_post_name: :title.md #默认布局模板是post，而不是draft和pagedefault_layout: post#是否将标题转换成标题形式（首字母大写）titlecase: false # Transform title into titlecase#在新标签页面中打开网页external_link: true # Open external links in new tabfilename_case: 0#是否渲染草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: false#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight: enable: true # 使用代码高亮 line_number: true # 显示行号 auto_detect: true # 自动检测语言 tab_replace:# 分类和标签# 默认分类default_category: uncategorized#分类别名category_map:#标签别名tag_map:# 日期和时间格式#Hexo 使用 Moment.js 来解析和显示时间。## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# 分页配置# ---------------下面选项需要对应插件的支持---------------# npm install hexo-generator-index --save# npm install hexo-generator-archive --save# npm install hexo-generator-category --save# npm install hexo-generator-tag --save## Set per_page to 0 to disable pagination#每页显示的文章量 #per_page: 20#首页的分页设置index_generator: per_page: 5#归档页的分页设置archive_generator: per_page: 30 yearly: true monthly: true#标签页的分页设置tag_generator: per_page: 20#分页路径，在public中可以看到#pagination_dir: page# Extensions 拓展插件配置## Plugins: https://hexo.io/plugins/plugins: baidusitemap: path: baidusitemap.xml# 配置RSSfeed: #feed 类型 (atom/rss2) type: atom #rss 路径 path: atom.xml #在 rss 中最多生成的文章数(0显示所有) limit: 0# 自定义站点内容搜索# 需要先安装插件：# npm install hexo-generator-search --savesearch: path: search.xml # 如只想索引文章，可设置为post field: all # 主题配置## Themes: https://hexo.io/themes/#theme: false #禁用主题#theme: landscapetheme: next# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/gylidian/gylidian.github.io.git #type: baidu_url_submitter查看效果您可以通过 hexo server 查看效果命令行工具hexo cleanhexo g 或 hexo generatehexo s 或 hexo serverhexo d 或 hexo deploy部署创建 github/coding 项目安装 hexo-deployer-git 插件1$ npm install hexo-deployer-git --savehexo 部署命令1$ hexo deploy在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如：12deploy: type: git您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。12345deploy:- type: git repo:- type: heroku repo:域名Coding Page 绑定域名绑定新域名强制 HTTPS 访问SSL/TLS 安全证书域名解析绑定前请在域名 DNS 设置中添加一条 CNAME 记录指向 gylidian.coding.me📘《从零开始的Hexo博客搭建教程》系列文章：从零开始的Hexo博客搭建教程（一）：开始从零开始的Hexo博客搭建教程（二）：主题从零开始的Hexo博客搭建教程（三）：SEO优化从零开始的Hexo博客搭建教程（四）：图床从零开始的Hexo博客搭建教程（五）：文章发布从零开始的Hexo博客搭建教程（六）：插件从零开始的Hexo博客搭建教程（七）：遇到的坑","link":"/h94Rf-/"},{"title":"从零开始的Hexo博客搭建教程（二）：主题","text":"🧁 为你的 Hexo 博客添加美观的主题，包括主题配置、分享、打赏、评论插件等。主题安装主题1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarusNext, replace the theme setting in your blog’s _config.yml file:1theme: icarus配置主题评论插件对比多款评论插件 后最终选用 gittalk，UI 非常美观使用 GitHub 登录支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]支持个人或组织无干扰模式（设置 distractionFreeMode 为 true 开启）快捷键提交评论 （cmd|ctrl + enter）npm 安装1$ npm i --save gitalk需要 GitHub Aplication如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。修改 _config.yml123456789101112comment: type: gitalk owner: xxxxxxxx # (required) GitHub user name repo: xxxxxxxx # (required) GitHub repository name client_id: xxxxxxxx # (required) OAuth application client id client_secret: xxxxxxxx # (required) OAuth application client secret admin: xxxxxxxx # (required) GitHub repo owner and collaborators who can initialize github issues # Can either be a string or an array. # admin: # - xxxxxx1 # - xxxxxx2其他配置项请 访问github 仓库 查看坑未找到相关的 Issues 进行评论请联系 @gylidian 初始化创建https://blog.csdn.net/dataiyangu/article/details/84961965📘《从零开始的Hexo博客搭建教程》系列文章：从零开始的Hexo博客搭建教程（一）：开始从零开始的Hexo博客搭建教程（二）：主题从零开始的Hexo博客搭建教程（三）：SEO优化从零开始的Hexo博客搭建教程（四）：图床从零开始的Hexo博客搭建教程（五）：文章发布从零开始的Hexo博客搭建教程（六）：插件从零开始的Hexo博客搭建教程（七）：遇到的坑","link":"/0IxRfH/"},{"title":"如何优雅地为博客添加打赏二维码功能","text":"1.打开“微信”。2.打开“我”，然后点击“钱包”。3.点击“收付码”。4.点击“赞赏码”。5.点击“开通赞赏码”。6.添加“赞赏引导语”，还可以根据需要修改“赞赏金额”，然后点击“生成赞赏码”。7.赞赏码生成完毕。","link":"/0gjs9V/"},{"title":"直播用HDMI采集卡选用指南及使用教程","text":"经过了 1 周的反复比对和折腾，我的采集卡终于到了。（闲鱼 650 ￥）血赚啊有木有？今年上半年，我将会以采集卡的艺术形象，正式开写，弘扬直播文化，文体两开花。我将会在这篇文章中普及 直播的基本知识 和 采集卡选用&amp;使用技巧。首先，不要把 HDMI 分线器、切换器当做 HDMI 采集卡，这不是 USB Hub 一样容易的事情。HDMI 有 out 和 in 区分。我曾希冀过是否存在不使用 HDMI 采集卡就可以录制主机游戏画面的方案，事实上，none。市面上的绝大多数笔记本的 HDMI 接口都是 out，也就是只能输出画面，不能输入画面。相对应地，显示器或者 TV 的 HDMI 接口则是 in。我也曾经想过使用游戏串流，但是网络和硬件配置不允许，延迟也极大，所以这个方案是不可能采用的。所以，只好乖乖用 HDMI 采集卡了呗。传输速度是否支持 USB3.0画面质量、帧数价格使用寿命圆钢不要买 4k 采集卡（4k 没有普及，不要买 4k），圆钢的稳定性非常好，画质看价格就好两千多就已经足够好了cv710usb3.0（USB3.1 不兼容）（PCI 转 3.0，3.1 不行）官方宣称延迟 0.02 秒。延迟 15~35ms，正常人的神经反应速度 0.2 秒、200ms 以上，人菜就不要怪延迟了，都是借口你还要算上网络延迟，输入延迟，加起来大于 200 你就有感觉了实际使用表示自己玩是没有延迟的，但是同时录制或直播会有轻微延迟g550用好几年了，cv710 至今仍然是游戏采集卡的性价比首选，延迟看软件，potplayer、recentral、obs 这几个软件都换着试试，经常是这个延迟明显另一个就完美直播码率的问题码率的问题","link":"/zfuGcl/"},{"title":"从零开始的Hexo博客搭建教程（三）：SEO优化","text":"🍰 本篇着重介绍了 Hexo 博客做 SEO 的一些小技巧，在内容优质程度不变的情况下如何针对搜索引擎展示或主动提交更多内容。为什么要做SEO？SEO”Search Engine Optimization”汉译为搜索引擎优化 ,搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式，搜索引擎优化是提高网站在搜索引擎结果中排名的战略。SEO非常耗时间，但“结果”是增加流量和更高的回报，而这需要您长久的悉心耕耘。我国互联网用户高达12.8亿，这意味着无论您提供什么样的业务，您的目标受众都可能会在搜索引擎上搜索类似的产品或服务，如果你想吸引他们到你的网站，你需要搜索引擎优化。它涉及确定目标受众在寻找像您这样的产品或服务时使用哪些关键词和短语，然后努力为这些搜索排名。您需要找到最有潜力和最少竞争的5或10个关键词。这些通用术语的流量通常非常高，并且可能会将网站变成一个流量生成的强国。搜索流量质量高：主动搜索的用户基本上都是有相关需求的，这些流量留存率高，转化率高，是非常优质的流量来源性价比高：相对于其他宣传方式，付出的成本低很多可扩展性：网站可以不停的增加关键词及相关流量长期有效： 一旦排名提上去，有效期较长网站标题优化SEO 最重要的是你的标题，一般搜索都是搜索你的标题。更改 index.swig 文件(your-hexo-site\\themes\\next\\layout);将下面这段代码：1{% block title %} {{ config.title }} {% endblock %}改成：1{% block title %} {{ config.title }} - {{ theme.description }} {% endblock %}这时候你的首页会更符合网站名称 - 网站描述这习惯。进阶，做了 seo 优化，把关键词也显示在 title 标题里，可改成：1{% block title %} {{ theme.keywords }} - {{ config.title }}{{ theme.description }} {% endblock %}注意：别堆砌关键字，整个标题一般不超过 80 个字符，可以通过 chinaz 的 seo 综合查询检查。生成 sitemap添加 sitemap 的目的是为了告诉搜索引擎你的站点结构。sitemap 生成插件的安装和配置12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save在站点配置文件中添加 sitemap 的生成路径1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml现在执行 hexo g 生成以后应该可以访问 sitemap.xml 和 baidusitemap.xml分别到谷歌和百度的站长工具网站上提交 sitemap 就可以了。如果不主动提交 sitemap，搜索引擎可能无法自己找到 sitemap，即使找到，速度也会很慢。github 好像屏蔽了百度的爬虫，所以即使提交了 sitemap，也可能出现无法爬下来的情况。于是我们需要主动向百度提交链接。让搜索引擎收录你的站点百度站长我们首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站。提交网址一般选 www.开头（题外话：一定要注意 github 和 coding 在绑定域名时也要顺便绑定 www 和非 www）百度新站保护经检测，您的站点符合百度新站保护要求，请先填写您网站的备案号，填写完成后您可以使用链接提交工具中的“新站保护”提交方式提交数据，百度将对此部分数据的抓取收录提供优待，为期2个月；备案信息可在站点属性工具中查看及修改。Google Search Console添加资源将该文件上传至 hexo 博客文件夹的 source/ 目录后部署即可。注意：一定要设置根目录下的 _config.yml123skip_render: #跳过渲染的文件列表 - googlexxxxxxxxxxxxxx.html #防止被渲染导致内容变更，不一致则无法验证所有权 - README.md提交 sitemap.xml打开 菜单 - 站点地图 提交 sitemap.xml 即可。向百度主动提交链接百度站长获取 token安装 hexo-baidu-url-submit 插件1npm install hexo-baidu-url-submit --save然后，同样在根目录下，把以下内容配置到_config.yml文件中:12345baidu_url_submit: count: 1 ## 提交最新的一个链接 host: www.nuist.today ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里其次，记得查看 _config.yml 文件中 url 的值， 必须包含是百度站长平台注册的域名（一般有 www）， 比如:1234# URLurl: https://www.nuist.todayroot: /permalink: post/:title/最后，加入新的 deployer:12deploy: - type: baidu_url_submitter执行hexo deploy 的时候，新的连接就会被推送了。robots.txt 文件在 your-hexo-site\\source 中新建 robots.txt，告诉搜索引擎，哪些是可以爬的，哪些是不可以爬的，格式如下：123456789101112131415161718#hexo robots.txtUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://hjptriplebee.github.io/search.xmlSitemap: https://hjptriplebee.github.io/sitemap.xmlSitemap: https://hjptriplebee.github.io/baidusitemap.xml外链 nofollow给非友情链接的出站链接添加 “nofollow” 标签，nofollow 标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。修改模板网站中的 href 出站链接最好添加 nofollow 标签，如：123{{ __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos; ) }}改成123{{ __(&apos;footer.powered&apos;,&apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;&apos;) }}这种方式修改貌似只能一个一个修改，有点麻烦，只修改了几处地方，或许有空可以研究 hexo 和 next 主题代码看如何进一步优化。使用 hexo-nofollow 插件为什么没有使用 hexo-autonofollow 插件呢原理：使用 cheerio 修改文章中每一个 &lt;a&gt;标签 的属性。安装1$ npm install hexo-nofollow --saveTo enable this plugin, insert the following to _config.yml:12nofollow: enable: trueOptions123456nofollow: enable: true exclude: - exclude1.com - exclude2.comexternal_link: trueenable - Enable the plugin. Defaults to false.exclude - Exclude hostname.external_link - Add target=&quot;_blank&quot;. Defaults to true.*Note:* external_link setting is already in the default _config.yml. Only add it if you can’t find it.文章 url 唯一且永久化HEXO 默认的文章链接形式为domain/year/month/day/postname，默认就是一个四级 url，并且可能造成 url 过长，对搜索引擎是十分不友好的，而且一旦文章名字改变，链接也跟着改变。有没有什么方法让地址尽量短小精悍，同时永久化呢？使用插件 hexo-abbrlink 可以做到，安装：1$ npm install hexo-abbrlink --save至于为什么不用 hexo-uuid，请看 hexo-abbrlink 插件的介绍。然后 hexo 的根目录配置文件_config.yml 中修改：1234permalink: p/:abbrlinkabbrlink: alg: crc16 # 算法：crc16(default) and crc32 rep: dec # 进制：dec(default) and hex这样就确保了博文链接的唯一化，只要不修改 md 文件的 abbrlink 的值，url 就永久不会改变。如此 md 文件名和文件内容也可以随便改了。这样也有利于 SEO 优化。_另外，在使用过程中我发现了一个 BUG，请注意不要在 hexo server 下直接编辑_post 文件夹中的文章，会导致整个文件直接被覆盖成 addrlink: xx。_打个广告（。＾ ▽ ＾）推荐好朋友 牛牛小可爱写的插件 🎀 hexo-nanoid本站已经在使用了文章关键词与描述搜索引擎除了主要抓取标题外，页面的关键词和描述也会抓取。在\\scaffolds\\post.md 中添加如下代码，用于生成的文章中添加关键字和描述。12keywords:description:其他养成良好的md图片书写习惯众所周知 &lt;img alt=&quot;&quot;&gt; 是有利于搜索引擎的，所以在markdown中指定图片时不要漏掉图片标题 ![图片标题](图片链接🔗)。遵循中文文案排版规范虽然这对SEO并无帮助，但这对于 增强网站气质、降低沟通成本 是必要的。排版、空白、标点符号 等的正确使用大有章法可循。这里提供一些参考资料↓sparanoid/chinese-copywriting-guidelines 中文文案排版指北ruanyf/document-style-guide 阮一峰的中文技术文档的写作规范📘《从零开始的Hexo博客搭建教程》系列文章：从零开始的Hexo博客搭建教程（一）：开始从零开始的Hexo博客搭建教程（二）：主题从零开始的Hexo博客搭建教程（三）：SEO优化从零开始的Hexo博客搭建教程（四）：图床从零开始的Hexo博客搭建教程（五）：文章发布从零开始的Hexo博客搭建教程（六）：插件从零开始的Hexo博客搭建教程（七）：遇到的坑","link":"/i5bofg/"},{"title":"又来盘点最大公约数的算法👩","text":"你媽的，为什么又双叒叕开学了！假期，你不要停下来啊！嘛，第一节课是 算法设计与分析课，郑某人带的学生由原来的俺们整个软工三个班换成原来俺们一个班和计嵌软嵌了。首先呢，郑某人自我介绍了一下：”我是普通老师郑玉！”，嗯，普通市民刘青云？还是 普通家庭马化腾？开学第一节课就讲最大公约数(greatest common divisor,简写为gcd)，老师要是不说我差点儿就忘了，俺就趁下课时间温习一下我遇到过的几个最大公约数的算法。来来来，先总结一下本文所有解法的时间复杂度：暴力枚举法：时间复杂度是 O(min(a, b)))辗转相除法：时间复杂度不太好计算，可以近似为 O(log(max(a, b)))，但是取模运算性能较差。更相减损术：避免了取模运算，但是算法性能不稳定，最坏时间复杂度为 O(max(a, b)))Stein算法：不但避免了取模运算，而且算法性能稳定，时间复杂度为 O(log(max(a, b)))暴力枚举法蛤蛤蛤，一听名字就知道这很暴力了，最耗时间，时间复杂度是 O(min(a, b)))。12345678910const gcd = (a, b) =&gt; { const small = a &lt; b ?a:b, big = a &gt;= b ?a:b; if(big%small==0) return small; let res = 1; for(const i=2;i&lt;=small/2; ++i) if(a%i==0 &amp;&amp; b%i==0) res = i; return res;}使用暴力枚举的方法，试图寻找到一个合适的整数 i，看看这个整数能否被两个整型参数 numberA 和 numberB 同时整除。这个整数 i 从2开始循环累加，一直累加到 numberA 和 numberB 中较小参数的一半为止，在循环中一直不断寻找能够被两数同时整除的最大 i 值。循环结束后最终得到的就是两数的最大公约数。性能分析：传入两个参数10000或10001，那么就需要计算10000/2-1=4999次。✨辗转相除法辗转相除法， 又名欧几里得算法（Euclidean algorithm），目的是求出两个正整数的最大公约数。它是已知最古老的算法， 其可追溯至公元前300年前。可半者半之，不可半者，副置分母、子之数，以少减多，更相减损，求其等也。以等数约之。这条算法基于一个定理：两个正整数a和b（a&gt;b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。比如10和25，25除以10商2余5,那么10和25的最大公约数，等同于10和5的最大公约数。一言以蔽之就是 两数a&gt;b, 结果就是 gcd(较小数, 余数)，简单吧？俺搜集了一堆算法👇（注：以下算法为了简洁就没有放大小判断，请保证a&gt;b）12345678910111213141516171819202122232425262728293031323334//递归实现const gcd = (a, b) =&gt; { if(!b) return a; return gcd(b, a%b);}//上面算法的简写const gcd = (a, b) =&gt; b == 0 ? a : gcd(b,a%b); //迭代实现const gcd = (a, b) =&gt; { int c = a%b; while(c){ a = b; b = c; c = a % b; } return b;}//用到了位运算const gcd = (a, b) =&gt; { while(b) { a%=b; b^=a; //这样写就是上面的分部写法 a^=b; //因为不这样写的话是会引起错误的，好像叫未定义行为 b^=a; //而分部写的话就不会出现这种错误 } return a; }//(慎用)上面算法的简写const gcd = (a, b) =&gt; { { while(b^=a^=b^=a%=b); //这样写是不正确的，因为这样写在不同的语言下又可能结果不同 return a; //这样写的格式是我从百度上看到的，思路和辗转相除一样，不是正确的完整写法}再来个充分利用ES6语法的超骚写法，摘自 30 seconds of code：1234const gcd = (...arr) =&gt; { const _gcd = (x, y) =&gt; (!y ? x : gcd(y, x % y)); return [...arr].reduce((a, b) =&gt; _gcd(a, b));};Example:12gcd(8, 36); // 4gcd(...[12, 8, 32]); // 4所以我们可以看到，辗转相除法的核心就是那个 取余 了对不对？欧几里德算法是计算两个数最大公约数的传统算法，他无论从理论还是从效率上都是很好的。然而它有一个致命的缺陷，这个缺陷只有在大素数时才会显现出来。那有没有什么办法能抛弃除法和取余呢？👇更相减损术更相减损术， 出自于中国古代的《九章算术》，也是一种求最大公约数的算法。他的原理更加简单：两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。比如10和25，25减去10的差是15,那么10和25的最大公约数，等同于10和15的最大公约数。换言之就是，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最终相等的两个数。一言以蔽之就是 两数a&gt;b，gcd(差值, 较小数)。123456789101112131415161718const gcd = (a, b) =&gt; { if(a == b) return a; if(a &lt; b) return gcd(b-a,a); else return gcd(a-b,b);}//迭代解法const gcd = (a, b) =&gt; { while(a!=b) if(a&gt;b) a-=b; else b-=a; return a; }//当然递归也可以这么写，无非就是循环次数不一样const gcd = (a, b) =&gt; { if (y == 0) return x; if (x &lt; y) return gcd(y, x); else return gcd(x - y, y); }更相减损术避免了大整数取余带来的性能问题，然而其按照求差的方式计算，将导致运算次数大大增加。比如当两数悬殊是10000和1时，就要递归9999次。因此更相减损术是一种不稳定算法。那有没有更好的算法既能规避取余又能保持较少的运算次数呢？👇Stein算法Stein算法由J. Stein 1961年提出，这个方法也是计算两个数的最大公约数。和欧几里德算法 算法不同的是，Stein算法只有整数的移位和加减法把辗转相除法和更相减损术的优势结合起来，在更相减损术的基础上使用移位。众所周知，移位运算的性能非常快。对于给定的正整数a和b，不难得到如下的结论：当a和b均为偶数，gcb(a,b) = 2*gcb(a/2, b/2) = 2*gcb(a&gt;&gt;1, b&gt;&gt;1)当a为偶数，b为奇数，gcb(a,b) = gcb(a/2, b) = gcb(a&gt;&gt;1, b)当a为奇数，b为偶数，gcb(a,b) = gcb(a, b/2) = gcb(a, b&gt;&gt;1)当a和b均为奇数，利用更相减损术运算一次，gcb(a,b) = gcb(b, a-b)， 此时a-b必然是偶数，又可以继续进行移位运算。比如计算10和25的最大公约数的步骤如下：整数10通过移位，可以转换成求5和25的最大公约数利用更相减损法，计算出25-5=20，转换成求5和20的最大公约数整数20通过移位，可以转换成求5和10的最大公约数整数10通过移位，可以转换成求5和5的最大公约数利用更相减损法，因为两数相等，所以最大公约数是5在两数比较小的时候，暂时看不出计算次数的优势，当两数越大，计算次数的节省就越明显。1234567891011121314151617181920212223//我的写法，看起来还算直观const gcd = (a, b) =&gt; { if(b==0) return a; if(a&lt;b) return gcd(b,a); const isEven = (x) =&gt; x&amp;1 == 0; // &amp;1 就等效为 %2 啦 if(isEven(a)) //分成了奇偶两种情况 if(isEven(b)) return gcd(b,a-b); else return gcd(a,b&gt;&gt;1); else if(isEven(b)) return gcd(a&gt;&gt;1,b); else return 2*gcd(a&gt;&gt;1,b&gt;&gt;1);}//或者这样写，网上看到的const gcd = (a, b) =&gt; { if(a == b) return a; if(a &lt; b) return gcd(b, a); // 保证参数a永远大于参数b，可减少代码量 else { // &amp;1相当于%2,&gt;&gt;1相当于/2 if(!a&amp;1 &amp;&amp; !b&amp;1) return gcd(a&gt;&gt;1,b&gt;&gt;1)&lt;&lt;1; else if(!a&amp;1 &amp;&amp; b&amp;1) return gcd(a&gt;&gt;1,b); else if(a&amp;1 &amp;&amp; !b&amp;1) return gcd(a,b&gt;&gt;1); else return gcd(a,a-b); }}（完）最后，给大家来一点开学表情包 😁😁😁","link":"/R52z1i/"},{"title":"给自己扫盲——文件完整性校验","text":"一直都在接触 md5 之类的东东，今天想起来深入了解一下，来弥补对这些加密算法常识上的缺失。嘛，文章还在写。本文旨在给我自己扫盲🙆‍~这涉及密码学的很多相关概念。什么是文件校验？文件校验 就是 使用算法验证计算机文件完整性的过程。你可以通过逐位(bit)比较两个文件来完成，但这需要同一文件的两个副本，并且可能会错过两个文件中可能出现的系统性损坏。更流行的方法是还存储文件的校验和（散列），也称为消息摘要，以供稍后比较。文件完整性验证文件可能会被各种方式破坏：存储介质故障，传输错误，复制或移动时写入错误，软件错误等。基于散列的验证通过将文件的散列值与先前计算的值进行比较来确保文件未被破坏。如果这些值匹配，则假定文件未修改。由于散列函数的性质，散列冲突可能导致误报，但是随机损坏，碰撞的可能性通常可以忽略不计。文件真实性验证CRC校验和不能用于验证文件的真实性，因为CRC32不是抗冲突的哈希函数 - 即使哈希和文件未被篡改，攻击者用相同的CRC摘要替换文件在计算上也是微不足道的。作为原始文件，意味着CRC比较未检测到文件中的恶意更改。一些概念密码散列函数（Cryptographic hash function）是散列函数的一种。它是一种单向加密函数算法，从明文到密文不可逆的映射，也就是说只有加密过程，不能逆向出原文。这种散列函数的输入数据，通常被称为消息（message），而它的输出结果，经常被称为消息摘要（message digest）或摘要（digest）。在信息安全中，有许多重要的应用，都使用了密码散列函数来实现，例如数字签名，消息认证码。一个理想的密码散列函数应该有四个主要的特性：对于任何一个给定的消息，它都很容易就能运算出散列数值。难以由一个已知的散列数值，去推算出原始的消息。在不更动散列数值的前提下，修改消息内容是不可行的。对于两个不同的消息，它不能给与相同的散列数值。一些重要的应用：保证数据的完整性单向数据加密数字签名对散列函数的攻击是不可避免的，所以在设计算法函数的意义就在于让它的破解在计算上不可行。这里的计算上不可行大概就是指用现有的设备理论上在多少年时间内都不可破解之。碰撞攻击不可避免听上去根本就不安全嘛！但没关系，评价散列函数的有效方法就是看一个攻击者找到一对产生碰撞的字符串所花的代价有多高。碰撞阻力是加密散列函数的一个属性：如果很难找到散列到同一输出的两个输入，则散列函数H是抗冲突的。碰撞阻力并不意味着不存在碰撞，只是他们很难找到。碰撞攻击（Collision attack）所谓哈希（hash），就是将不同的输入映射成独一无二的、固定长度的值（又称”哈希值”）。如果存在一种相对“廉价”的方法，用不同的消息找到两个相同的摘要，则称之为哈希碰撞（collision）防止哈希碰撞的最有效方法，就是扩大摘要长度（即哈希值的取值空间）。哈希碰撞的概率取决于两个因素（假设哈希函数是可靠的，每个值的生成概率都相同）：取值空间的大小（即哈希值的长度）整个生命周期中，哈希值的计算次数目前散列函数的攻击方法：第一类称为穷举攻击（或暴力攻击）它能对任何类型的散列函数进行攻击。这里涉及生日攻击（birthday attack），一种利用哈希空间不足够大，而制造碰撞的攻击方法。为了限制本文篇幅，则不再引申。如果存在比这种暴力攻击更简单的方法，则通常将其视为散列函数中的缺陷。第二类称为密码分析法这类攻击方法依赖于对散列函数的结构和代数性质分析，采用针对散列函数弱性质的方法进行攻击。这类攻击方法有中间相遇攻击、差分分析等。原像攻击（Preimage attack）在加密中， 对加密散列函数的原像攻击指试图找到具有特定散列值的消息。加密哈希函数应该抵制对其原像的攻击。在攻击的情况下，有两种类型的原像抗性：第一原像抗性（preimage resistance）：对于基本上所有预先指定的输出，找到任何哈希到该输出的输入在计算上是不可行的，即，给定 y​，很难找到 x​ 使得 h(x)= y​。第二原像抗性（second preimage resistance）：找到任何与指定输入具有相同输出的第二输入在计算上是不可行的，即给定 x，很难找到第二个原像 x’（x’≠x），使得 h(x)= h(x’)。再复习一遍 抗冲突性（Collision resistance），在计算上极其难以找到散列到相同输出的任何两个不同的输入x，x ‘，使得h（x）= h（x ‘）。常见校验算法俺针对几种常见算法总结并画了张图。👇CRC-32MD5MD5由国际著名密码学家图灵奖获得者兼公钥加密算法RSA的创始人Rivest设计。当前，MD5算法因其普遍、稳定、快速的特点，仍广泛应用于普通数据的错误检查领域。例如在一些BitTorrent下载中，软件将通过计算MD5检验下载到的文件片段的完整性。实现原理填充：将输入信息进行512求余分组，若不等于448，那么进行填充 1 和0，一个1 N个0。最后的数据就为N*512+448。记录信息长度：将得到的信息用64位存储填充之前的信息长度，这样448+64=512，总信息为N+1个512。以四个常数ABCD与每组512位进行函数运算，最后输出的结果就是4组32位的常数。拼接得到MD5码。缺陷MD5的安全性：将用户的密码直接MD5后存储在数据库是不安全的。第一，用户普遍习惯用容易记忆的密码，生日，手机号等，黑客容易破译此类密码。这也是加盐值的一个原因。第二，直接MD5存入数据库，若数据库被破解，通过MD5反查会查到密码，需要随机盐值的配合。md5绕过(Hash比较缺陷)：在PHP中，由于0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，开头是0e的md5字符串都会被当成0。很容易遭到rainbow table攻击。SHA-1SHA-1是由美国专门制定密码算法的标准机构——美国国家标准技术研究院（NIST）与美国国家安全局（NSA）设计。与MD5比较因为二者均由MD4导出，SHA-1和MD5彼此很相似。相应的，他们的强度和其他特性也是相似，但还有以下几点不同：对强行攻击的安全性：最显著和最重要的区别是SHA-1摘要比MD5摘要长32 位。使用强行技术，产生任何一个报文使其摘要等于给定报摘要的难度对MD5是 $$2^{128}$$ 数量级的操作，而对SHA-1则是 $$2^{160}$$ 数量级的操作。这样，SHA-1对强行攻击有更大的强度。对密码分析的安全性：由于MD5的设计，易受密码分析的攻击，SHA-1显得不易受这样的攻击。速度：在相同的硬件上，SHA-1的运行速度比MD5慢。早在2005年中国山东大学的教授王小云就实现了快于暴力破解的攻击技术。2005年的攻击能够在2的69次方计算中找到碰撞，或者说是暴力破解的2000倍，如密码学大师施耐尔所言“远超当前技术的能力”。此次CWI和谷歌的方法，则“超过暴力破解的10万倍。”因次被称为入侵SHA-1加密算法数字签名的“首次可行性技术”。“暴力破解需要1200万年的GPU计算时间，因此是不实际的。而SHAttered攻击要快上10万倍。攻击需要超过90亿亿次（没打错，是两个“亿” 9,223,372,036,854,775,808 ）计算，等同于6500年的单个CPU时间和110年的单个GPU时间。”SHA-2SHA-224、SHA-256、SHA-384，和SHA-512并称为SHA-2。新的散列函数并没有接受像SHA-1一样的公众密码社区做详细的检验，所以它们的密码安全性还不被大家广泛的信任。虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法。SHA-3SHA-3，之前名为Keccak算法，是一个加密杂凑算法。SHA-3并不是要取代SHA-2，因为SHA-2目前并没有出现明显的弱点。由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密杂凑算法，也就是现在的SHA-3。附录对散列函数碰撞攻击的破解现状","link":"/aUE-KU/"},{"title":"动手魔改hexo-theme-icarus主题","text":"Icarus 是一款 简单、优雅、现代化 的 Hexo 博客主题。“最新文章”卡片 修改缩略图链接如下图所示，recent_posts 中显示的文章列表的缩略图都是原图(文件较大)，虽然每个图片大小只有几百KB而已，但是为了节省流量，我们还是选择将这里的缩略图压缩，压缩后往往只有十几KB。STEP1 新增图片处理自定义版本首先，我在 又拍云 新增了一个图片处理的自定义版本，功能配置中 把你认为能削减文件大小的选项都勾上。至于间隔标识符，我延用默认的 !。这样，通过在图床图片URL结尾添加 !small，你就可以获取其压缩后的图片版本。STEP2 魔改主题模板进入hexo所在文件目录打开 theme/icarus/_config.yml，放入以下配置12# 图床（啊哈呵嗨）imghosting: 你的图床的BaseUrl打开 themes/icarus/includes/helpers/page.js，修改辅助函数 get_thumbnail123456789hexo.extend.helper.register(\"get_thumbnail\", function(post, version) { const hasThumbnail = hexo.extend.helper.get(\"has_thumbnail\").bind(this)(post); const imgHosting = hexo.theme.config.imghosting; const thumbnailUrl = hasThumbnail &amp;&amp; post.thumbnail.startsWith(imgHosting) &amp;&amp; version ? `${post.thumbnail}${version}` : post.thumbnail; return this.url_for(hasThumbnail ? thumbnailUrl : \"images/thumbnail.svg\");});打开 theme/icarus/layout/widget/recent_posts.ejs，找到123&lt;p class=&quot;image is-64x64&quot;&gt; &lt;img class=&quot;thumbnail&quot; src=&quot;&lt;%= get_thumbnail(post) %&gt;&quot; alt=&quot;&lt;%= post.title %&gt;&quot;&gt;&lt;/p&gt;把 get_thumbnail(post) 改成 get_thumbnail(post,'!small')。STEP3 查看效果执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 即可。为鼠标点击添加烟花效果打开 themes/icarus/layout/layout.ejs，在 &lt;body&gt; 下方添加：1&lt;canvas class=&quot;fireworks&quot;&gt;&lt;/canvas&gt;至于 CSS 样式，我选择放入 themes/icarus/source/css/style.styl1234567/* --------------------------------- * 鼠标点击烟花效果 * --------------------------------- */.fireworks position: fixed z-index: -1 pointer-events: none新建文件 themes/icarus/source/js/firework.js，放入代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122var canvasEl = document.querySelector(\".fireworks\");if (canvasEl) { var ctx = canvasEl.getContext(\"2d\"), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = \"mousedown\", colors = [\"#FF1461\", \"#18FF92\", \"#5A87FF\", \"#FBF38C\"], setCanvasSize = debounce(function() { (canvasEl.width = window.innerWidth), (canvasEl.height = window.innerHeight), (canvasEl.style.width = window.innerWidth + \"px\"), (canvasEl.style.height = window.innerHeight + \"px\"), canvasEl.getContext(\"2d\").scale(1, 1); }, 500), render = anime({ duration: 1 / 0, update: function() { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height); } }); document.addEventListener( tap, function(e) { \"sidebar\" !== e.target.id &amp;&amp; \"toggle-sidebar\" !== e.target.id &amp;&amp; \"A\" !== e.target.nodeName &amp;&amp; \"IMG\" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)); }, !1 ), setCanvasSize(), window.addEventListener(\"resize\", setCanvasSize, !1);}function updateCoords(e) { (pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left), (pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top);}function setParticuleDirection(e) { var t = (anime.random(0, 360) * Math.PI) / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return { x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) };}function createParticule(e, t) { var a = {}; return ( (a.x = e), (a.y = t), (a.color = colors[anime.random(0, colors.length - 1)]), (a.radius = anime.random(16, 32)), (a.endPos = setParticuleDirection(a)), (a.draw = function() { ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), (ctx.fillStyle = a.color), ctx.fill(); }), a );}function createCircle(e, t) { var a = {}; return ( (a.x = e), (a.y = t), (a.color = \"#F00\"), (a.radius = 0.1), (a.alpha = 0.5), (a.lineWidth = 6), (a.draw = function() { (ctx.globalAlpha = a.alpha), ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), (ctx.lineWidth = a.lineWidth), (ctx.strokeStyle = a.color), ctx.stroke(), (ctx.globalAlpha = 1); }), a );}function renderParticule(e) { for (var t = 0; t &lt; e.animatables.length; t++) e.animatables[t].target.draw();}function animateParticules(e, t) { for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) n.push(createParticule(e, t)); anime .timeline() .add({ targets: n, x: function(e) { return e.endPos.x; }, y: function(e) { return e.endPos.y; }, radius: 0.1, duration: anime.random(1200, 1800), easing: \"easeOutExpo\", update: renderParticule }) .add({ targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: { value: 0, easing: \"linear\", duration: anime.random(600, 800) }, duration: anime.random(1200, 1800), easing: \"easeOutExpo\", update: renderParticule, offset: 0 });}打开 themes/icarus/layout/common/scripts.ejs，追加代码：12&lt;%- _js(cdn(&apos;animejs&apos;, &apos;3.0.1&apos;, &apos;lib/anime.min.js&apos;)) %&gt;&lt;%- _js(&apos;js/firework&apos;, true) %&gt;这就🆗啦，赶快 素质三连( hexo clean &amp;&amp; hexo g &amp;&amp; hexo s ) 查看效果吧！(´▽`ʃ♡ƪ)改造”TOC”卡片添加 sticky 效果🔔 BUG 待修复：在中屏自适应情况下无法 sticky打开 themes/icarus/source/css/style.styl，找到以下样式所在位置12345678910111213@media screen and (min-width: screen-tablet) .column-main, .column-left, .column-right, .column-right-shadow &amp;.is-sticky align-self: flex-start position: -webkit-sticky position: sticky top: .75rem .column-right-shadow &amp;.is-sticky top: 1.5rem将其修改为123456789101112131415161718@media screen and (min-width: screen-tablet) .column-main, .column-left, .column-right, .column-right-shadow, #toc &amp;.is-sticky align-self: flex-start position: -webkit-sticky position: sticky top: .75rem .column-right-shadow &amp;.is-sticky top: 1.5rem #toc &amp;.is-sticky max-height: calc(100vh - 2rem) overflow-y: auto打开 theme/icarus/_config.yml，对 sidebar 追加以下配置12345678910sidebar: # left sidebar settings left: sticky: false # right sidebar settings right: sticky: false # 使TOC支持sticky效果（啊哈呵嗨） toc: sticky: true打开 themes/icarus/layout/widget/toc.ejs，修改代码：12345678910111213141516171819202122&lt;% function toc_sticky_class() { let canTocSticky, position; get_widgets(&apos;left&apos;).forEach(widget =&gt; { if(widget.type === &apos;toc&apos;) position = widget.position; }); get_widgets(&apos;right&apos;).forEach(widget =&gt; { if(widget.type === &apos;toc&apos;) position = widget.position; }); if(position &amp;&amp; get_config(&apos;sidebar.&apos; + position + &apos;.sticky&apos;, false)) canTocSticky = false; else canTocSticky = get_config(&apos;sidebar.toc.sticky&apos;, false); return canTocSticky ? &apos;is-sticky&apos; : &apos;&apos;;} %&gt;&lt;div class=&quot;card widget &lt;%= toc_sticky_class() %&gt;&quot; id=&quot;toc&quot;&gt; &lt;div class=&quot;card-content&quot;&gt; &lt;div class=&quot;menu&quot;&gt; &lt;h3 class=&quot;menu-label&quot;&gt; &lt;%= _p(&apos;widget.catalogue&apos;, Infinity) %&gt; &lt;/h3&gt; &lt;%- buildToc(_toc(post.content)) %&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;TOC 标题随滚动定位新建 themes/icarus/layout/plugin/tocbot.ejs12345678910111213141516171819202122232425262728293031323334353637&lt;% if (get_config(&apos;toc&apos;) === true &amp;&amp; plugin !== false &amp;&amp; (page.layout === &apos;page&apos; || page.layout === &apos;post&apos;)) { %&gt;&lt;% if (head) { %&gt;&lt;style&gt;.toc-list{margin:0;list-style:none}a.toc-link{color:currentColor;height:100%;border-radius:4px;color:#4a4a4a;display:block;padding:0.5em 0.75em}.is-collapsible{max-height:1000px;overflow:hidden;transition:all 300ms ease-in-out}.is-collapsed{max-height:0}.is-position-fixed{position:fixed !important;top:0}.is-active-link{font-weight:700}&lt;/style&gt;&lt;% } else { %&gt;&lt;%- _js(&apos;js/reading-progress.js&apos;) %&gt;&lt;%- _js(cdn(&apos;tocbot&apos;, &apos;4.5.0&apos;, &apos;dist/tocbot.min.js&apos;)) %&gt;&lt;script&gt; $(function () { tocbot.init({ tocSelector: &apos;#toc-content&apos;, contentSelector: &apos;.article .content&apos;, headingSelector: &apos;h2, h3, h4&apos; }); // modify the toc link href to support Chinese. let i = 0; let tocHeading = &apos;toc-heading-&apos;; $(&apos;#toc-content a&apos;).each(function () { $(this).attr(&apos;href&apos;, &apos;#&apos; + tocHeading + (++i)); }); // modify the heading title id to support Chinese. i = 0; $(&apos;.article .content&apos;).children(&apos;h2, h3, h4&apos;).each(function () { $(this).attr(&apos;id&apos;, tocHeading + (++i)); }); });&lt;/script&gt;&lt;% } %&gt;&lt;% } %&gt;打开 theme/icarus/_config.yml，新增配置123plugins: # tocbot（啊哈呵嗨） tocbot: true修改 toc.ejs，找到代码1&lt;%- buildToc(_toc(post.content)) %&gt;将其换成12345&lt;% if (get_config(&apos;plugins.tocbot&apos;) !== false) {%&gt;&lt;div id=&quot;toc-content&quot;&gt;&lt;/div&gt;&lt;% } else { %&gt;&lt;%- buildToc(_toc(post.content)) %&gt;&lt;% } %&gt;添加 阅读进度滚动条打开 themes/icarus/layout/widget/toc.ejs，找到代码：1&lt;div class=&quot;card widget &lt;%= toc_sticky_class() %&gt;&quot; id=&quot;toc&quot;&gt;在下方加入123&lt;div class=&quot;reading-progress&quot;&gt; &lt;div class=&quot;reading-progress-bar&quot;&gt;&lt;/div&gt;&lt;/div&gt;添加样式，不用说都知道修改哪个文件了吧？1234567891011121314/* --------------------------------- * 阅读进度滚动条 * --------------------------------- */.reading-progress width: 100%; height: 4px; opacity: .8; background-color: rgba(37, 117, 252, .3); overflow: hidden .reading-progress-bar background-image: linear-gradient(to right,#4cbf30 0,#0f9d58 100%); height: 4px; width: 0;页面浏览器标题修改打开 themes/icarus/includes/helpers/page.js，在辅助函数 page_title 中找到以下代码片段1234const siteTitle = hexo.extend.helper.get(\"get_config\").bind(this)(\"title\", \"\", true);return [title, siteTitle] .filter(str =&gt; typeof str !== \"undefined\" &amp;&amp; str.trim() !== \"\") .join(\" - \");将其修改为123456const getConfig = hexo.extend.helper.get(\"get_config\").bind(this);const siteTitle = getConfig(\"title\", \"\", true), siteSubTitle = getConfig(\"subtitle\", \"\", true);return [title, siteTitle, siteSubTitle] .filter(str =&gt; typeof str !== \"undefined\" &amp;&amp; str.trim() !== \"\") .join(\" - \");执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 即可查看效果。百度站长自动推送工具打开 themes/icarus/layout/common/scripts.ejs，追加1234567891011121314&lt;script&gt; (function () { var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s); })();&lt;/script&gt;支持百度 MIP 和 AMP打开 themes/icarus/layout/common/head.ejs，追加12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"https://c.mipcdn.com/static/v2/mip.css\"&gt;&lt;link rel=\"canonical\" href=\"&lt;%= url %&gt;\"&gt;打开 themes/icarus/layout/common/scripts.ejs，追加1&lt;script src=\"https://c.mipcdn.com/static/v2/mip.js\"&gt;&lt;/script&gt;打开 themes\\icarus\\layout\\layout.ejs，给 html 标签 添加属性 mip使 MathJax 和 Gallery 插件支持文章中开启数学公式 和 图片展览 的使用频次实在是太少了，当你用不到的时候页面上就会加载 mathjax 和 gallery 的诸多额外 js，对网站速度还是有一定的影响的。那么我们就修改一下配置，让 post 支持选择性启用这些插件吧！支持 QQ 分享题外话：hexo 是如何通过 &lt;!-- more --&gt; 分割文章从而获得 excerpt 的。https://github.com/hexojs/hexo/blob/master/lib/plugins/filter/after_post_render/excerpt.js打开 themes/icarus/layout/common/head.ejs，在合适的位置添加123&lt;meta itemprop=\"name\" content=\"&lt;%= page_title() %&gt;\" /&gt;&lt;meta itemprop=\"description\" content=\"&lt;%= aha_description() %&gt;\" /&gt;&lt;meta itemprop=\"image\" content=\"&lt;%= page.thumbnail || get_config('url') + '/images/avatar.png' %&gt;\" /&gt;打开 themes/icarus/includes/helpers/page.js，添加新辅助函数 aha_description12345678910111213141516hexo.extend.helper.register(\"aha_description\", function(page = null) { page = page === null ? this.page : page; const configDescription = hexo.extend.helper.get(\"get_config\").bind(this)(\"description\",\"\"); let description = page.excerpt || page.description || configDescription; if (description) { description = stripHTML(description).substring(0, 200) .trim() .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\") .replace(/&amp;/g, \"&amp;amp;\") .replace(/\"/g, \"&amp;quot;\") .replace(/'/g, \"&amp;apos;\") .replace(/\\n/g, \" \"); } return description;});文章标题下划线动画打开 themes/icarus/source/css/style.styl，追加123456789101112/* --------------------------------- * 标题下划线动画 * --------------------------------- */.title a background-image: linear-gradient(transparent 0%, transparent 65%,#a4c7ff 65%,#a4c7ff 90%, transparent 90%, transparent); background-repeat: no-repeat; background-size: 0 100%; transition: background-size .3s cubic-bezier(0.4, 0, 1, 1); &amp;:hover background-size: 100% 100%;添加”待办事项”卡片添加样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/* --------------------------------- * TODO卡片 * --------------------------------- */.clearfix overflow: auto zoom: 1.todo-header border-radius: 6px 6px 0 0 background: url(\"/images/aha-todo-bg.jpg\") no-repeat background-size: cover padding: 30px position: relative time color: white display: block letter-spacing: .125rem .day font-size: 4rem float: left margin-right: 10px .dayofweek display: block margin-top: 13px font-size: 1.4rem font-weight: 700 .add-circle position: absolute background: #ff3c41 color: white border-radius: 50% width: 40px height: 40px line-height: 40px text-align: center right: 20px bottom: -20px box-shadow: 0 0 13px #ff3c41 cursor: pointer.todo-form margin: 15px 0 width: 100% input width: 100% border: 0 border-bottom: 1px solid #e6e6e6 font-family: inherit padding: 5px 0 outline: none &amp;:focus border-bottom-color: #ff3c41.todo-content .todo-content-title padding: 20px h2 font-size: 1.5rem font-weight: normal color: #4c4646 .task-report font-size: 0.9rem color: #afafaf.todo-list list-style: none .task-item padding: 15px 20px border-top: 1px solid #f1f1f1 position: relative &amp;.task-done .text color: #ccc .label display: inline-block background: #ff3c41 width: 15px height: 15px border-radius: 50% float: left margin-right: 10px &amp;.normal background: #37eaa0 .text position: relative top: -2px .task-action position: absolute right: 20px top: 12px z-index: 99999 .more cursor: pointer span display: inline-block margin: 0 1px width: 6px height: 6px border-radius: 50% background: #d0d0d0 .action-list position: absolute right: 0px top: 23px border: 1px solid #ccc list-style: none padding: 15px 10px border-radius: 4px background: #fff box-shadow: 0 4px 7px rgba(0, 0, 0, 0.1) display: none li padding: 3px 5px cursor: pointer white-space: nowrap &amp;:hover background: #0ebeff color: white border-radius: 3px &amp;:focus .action-list display: block向配置文件中添加配置：12345678910111213141516widgets: - type: todo # 待办事项 Widget（啊哈呵嗨） position: right tasks: About 页面大修: done: false # 默认为false，即未完成 type: 1 # 0代表normal 1代表urgent 默认为0，即normal TOC 滚动更新位置: done: true type: 0 设计 Logo SVG: done: false type: 0 todo 小组件大小单位用 rem: done: false type: 0新建文件 themes/icarus/layout/widget/todo.ejs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;% const weekdayArr= new Array(&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;);const monthArr = [&apos;一月&apos;,&apos;二月&apos;,&apos;三月&apos;,&apos;四月&apos;,&apos;五月&apos;,&apos;六月&apos;,&apos;七月&apos;,&apos;八月&apos;,&apos;九月&apos;,&apos;十月&apos;,&apos;十一月&apos;,&apos;十二月&apos;];const myDate = new Date(); const dayofweek = weekdayArr[myDate.getDay()], day = myDate.getDate(), month = monthArr[myDate.getMonth()]; %&gt;&lt;% const tasks = get_config_from_obj(widget, &apos;tasks&apos;);let doneNum = 0, taskNum = 0;for(const i in tasks) { taskNum++; if(tasks[i].hasOwnProperty(&apos;done&apos;) &amp;&amp; tasks[i].done === true) doneNum++;} %&gt;&lt;div class=&quot;card widget todo-wrapper&quot;&gt; &lt;div class=&quot;todo-header&quot;&gt; &lt;time class=&quot;clearfix&quot;&gt; &lt;span class=&quot;day&quot;&gt;&lt;%= day %&gt;&lt;/span&gt; &lt;span class=&quot;dayofweek&quot;&gt;&lt;%= dayofweek %&gt;&lt;/span&gt; &lt;span class=&quot;month&quot;&gt;&lt;%= month %&gt;&lt;/span&gt; &lt;/time&gt; &lt;div class=&quot;add-circle&quot;&gt; &lt;i class=&quot;fa fa-plus&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;todo-content&quot;&gt; &lt;div class=&quot;todo-content-title&quot;&gt; &lt;h2&gt;Blog tasks&lt;/h2&gt; &lt;p class=&quot;task-report&quot;&gt;&lt;span class=&quot;task-remain&quot;&gt;&lt;%= doneNum %&gt;&lt;/span&gt; / &lt;%= taskNum %&gt; tasks&lt;/p&gt; &lt;/div&gt; &lt;ul class=&quot;todo-list&quot;&gt; &lt;% for (const i in tasks) { %&gt; &lt;% const hasDone = tasks[i].hasOwnProperty(&apos;done&apos;) &amp;&amp; tasks[i].done; %&gt; &lt;li class=&quot;task-item &lt;%= hasDone ? &apos;task-done&apos; : &apos;&apos; %&gt;&quot;&gt; &lt;span class=&quot;label &lt;%= tasks[i].hasOwnProperty(&apos;type&apos;) &amp;&amp; tasks[i].type ? &apos;urgent&apos; : &apos;normal&apos; %&gt;&quot;&gt;&lt;/span&gt; &lt;% if (hasDone) { %&gt; &lt;del class=&quot;text&quot;&gt;&lt;%= i %&gt;&lt;/del&gt; &lt;% } else { %&gt; &lt;p class=&quot;text&quot;&gt;&lt;%= i %&gt;&lt;/p&gt; &lt;div class=&quot;task-action&quot;&gt; &lt;i class=&quot;more&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt; &lt;/i&gt; &lt;ul class=&quot;action-list&quot;&gt; &lt;li&gt;Mark done&lt;/li&gt; &lt;li&gt;Edit&lt;/li&gt; &lt;li&gt;Delete&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;% } %&gt; &lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;首页和非首页两种 widget首先将 配置中的 widgets 拷贝一份到 index_widgets 后自行配置。接着把 themes/icarus/includes/helpers/layout.js 中的所有辅助函数都加上一个参数用于判断是否首页1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Helper functions for controlling layout. * * @example * &lt;%- get_widgets(position) %&gt; * &lt;%- has_column() %&gt; * &lt;%- column_count() %&gt; */module.exports = function(hexo) { hexo.extend.helper.register(\"has_widget\", function(type, isHome = false) { const hasWidgets = hexo.extend.helper.get(\"has_config\").bind(this)( isHome ? \"index_widgets\" : \"widgets\" ); if (!hasWidgets) { return false; } const widgets = hexo.extend.helper.get(\"get_config\").bind(this)( isHome ? \"index_widgets\" : \"widgets\" ); return widgets.some(widget =&gt; widget.hasOwnProperty(\"type\") &amp;&amp; widget.type === type); }); hexo.extend.helper.register(\"get_widgets\", function(position, isHome = false) { const hasWidgets = hexo.extend.helper.get(\"has_config\").bind(this)( isHome ? \"index_widgets\" : \"widgets\" ); if (!hasWidgets) { return []; } const widgets = hexo.extend.helper.get(\"get_config\").bind(this)( isHome ? \"index_widgets\" : \"widgets\" ); return widgets.filter( widget =&gt; widget.hasOwnProperty(\"position\") &amp;&amp; widget.position === position ); }); hexo.extend.helper.register(\"has_column\", function(position, isHome = false) { const getWidgets = hexo.extend.helper.get(\"get_widgets\").bind(this); return getWidgets(position, isHome).length &gt; 0; }); hexo.extend.helper.register(\"column_count\", function(isHome = false) { let columns = 1; const hasColumn = hexo.extend.helper.get(\"has_column\").bind(this); columns += hasColumn(\"left\", isHome) ? 1 : 0; columns += hasColumn(\"right\", isHome) ? 1 : 0; return columns; });};接着修改所有出现以上3个辅助函数的模板，比如 themes/icarus/layout/common/widget.ejs、themes/icarus/layout/layout.ejs，把 is_home() 用做参数即可。","link":"/Qa1Ssx/"},{"title":"《Tetris:99》俄罗斯方块吃鸡从入门到进阶","text":"北京时间2019年2月14日上午9时，一场35分钟的任天堂直面会开始了。这次今年第一场直面会内容巨多，尤其是 《火焰纹章：风花雪月》、《任天堂明星大乱斗 特别版》3.0、《哆啦A梦：大雄的牧场物语》、《耀西的手工世界》《超级玛利欧制造 2》《塞尔达传说 织梦岛》等游戏，遭到了大家的热议，实在是太令人兴奋了！正当所有人沉浸在情人节的快感之中时，只有你对着屏幕上的 Nintendo Direct 高潮迭起。咳咳，言归正传！（单身狗流泪）而就在这时，人群当中钻出了一个光头，Tetris 99！一款由Arika出品任天堂发布的免费联机游戏！你很纳闷，为什么会有这样一款幼稚的俄罗斯方块的4399小游戏值得振奋，还在不到一周时间里迅速攻占了多个社交平台。（你可能没玩过3ds、nds等版本的 Tetris，你不知道这背后悠久的游戏进化史）但是，因为这是款免费下载（会员特典）的游戏，你还是毫不犹豫的下载了。而就在几分钟之后…………………俄罗斯鸡块，真香！简介俄罗斯方块99，简单来说，就是99人即时对战的俄罗斯方块。玩家可以在所有对手之间随时切换攻击目标。游戏设计师通过基本层面和策略层面，来实现具体的对战：基本层面的攻击：当玩家消除掉N行或者N行以上方块时，就可以对敌手产生攻击。当N&gt;1时，被攻击者的盘面底部，会出现N-1行灰色方块（其中有一格是空的，我们称之为垃圾行），如果N=4，则会出现N行方块。基本知识guideline规则10列20行的游戏场地，超过20行以上的行将被场框隐藏或阻挡IOTSZJL 七种方块分别对应 青、黄、紫、绿、红、蓝、橙 七种颜色SRS 旋转系统：包括起始方向，可行的踢墙等科普一下旋转系统：SRS(Super Rotate System)，是现在 Tetris guideline 里的标准旋转系统ARS(Arika Rotate System)，是街机游戏TGM（Tetris The Grand Master）里的旋转系统以上这两种是最常见的了DRS查了下是DTET的旋转系统CRS应该是Cultris（一版比较奇葩的俄罗斯方块游戏）中的旋转系统7-bag 系统：每7个方块必然是IOTSZJL各一个，顺序随机将7种方块随机排序，生成7个为一个包(Bag)，然后一包一包连接起来就是方块序列。这样任意一中方块重复出现的最大间隔就不会超过12个，出现两个连续相同方块的概率也比较小。除了 SRS 使用的随机方块产生器 7-bag，其他随机方块序列生成算法还有：roll4，即 History 4 Roll Randomizer，TGM1, TGM2, TGM2P使用的随机方块产生器。roll6，即 History 6 Roll Randomizer，TGM3使用的随机方块产生器。有一个长为4的历史纪录，产生新方块时，尝试4或6次(分别叫History 4 Roll Randomizer、History 6 Roll Randomizer)，每一次尝试就是随机选择一种方块，若在历史中存在，则此次尝试失败，进入下一次尝试。如果历史记录中不存在此方块，则立即选用此方块。最后把历史记录向前推进，把新产生的这个加进去。memoryless randomizer，无记忆随机方块产生器，也就是线性地等概率取随机方块。next：玩家可以看到接下来的1-6个方块（在上面的三个游戏里都是6个）hold：方块暂存，可供需要的时候使用支持 T-spin 判定：可以用T方块旋转进入凹槽消行的方式进行攻击支持 Combo 判定：可以用连续消行的方式进行攻击* 更多详细规则请参见 Tetris Wiki基本玩法每块方块落下的过程中，我们可以做：1）旋转到合适的方向2）水平移动到某一列3）垂直下落到底部经典的多人对战玩法对手给你制造大量的“垃圾方块”界面&amp;操作主界面只有三个入口，该游戏连练习模式、入门tips都没有，需要你在对战中自行摸索点击 自动匹配基本操作BGM三拍四拍鼓点八节拍为一节，2节节奏递进。顺时针3D音效 电音就像心跳一样节奏听起来非常带感，尤其是配合那个旋转的背景魔性得很游戏界面PLACEHOLD一方面是增添储备格。按 L 键，可以存起正在下落的方块，但最多只能存 1 块，后面遇到需要存起的方块，就会把储存格的方块「取出」替代现有的方块。按L键可以暂留一个方块作备用之需。NEXT可以看到即将出现的 6 块方块在「预告方块」变多之后，玩家就能做更详尽的规划，合理利用好现有和接下来的方块。Watch Out对手红色代表危急状态，如果你被结算画面紫色代表被人击杀红色代表K.O.你的对手带有K.O.图标的则是你击杀的对手对战机制我们只要消除方块，就能够攻击其他玩家。攻击方式就是在屏幕底部向上发射方块。你消除的层数越多，则攻击其他玩家的层数也越多，成正比关系。相反，其他玩家如果攻击你的话，亦是如此。好在我们可以通过快速消除自己屏幕的方块来抵消其他玩家攻击你的方块层数。因为攻击机制是有时间差的，所以只要再攻击判定以前消除足够量的方块，我们就可以化险为夷。垃圾砖块（garbage lines）By clearing lines the player can send lines of garbage to opponents.Lines received will go into the pending garbage queue, where there is a delay before the lines appear on the playfield. This delay decreases as players are knocked out. The active set of pending lines will change colour to indicate how close it is to appearing, and when the active set spawns on the playfield the next set will become active.The player can have at most 12 lines of garbage in their pending queue, and can send at most 20 with one line clear. In both cases any excess lines are lost.缩圈类似吃鸡的「jue 圈」，50 人、10 人阶段会加快速度，不是那么容易适应。随着游戏越来越多的人出局，系统则会加快方块掉落速度，同时BGM的节奏则变得更加紧凑，给你带来一种无形的心理压迫。再加上最后玩家数量越来越少，你被攻击的频率会变得越来越高，此时就必须提高消除效率了，如果出现一个小的失误，则可能就会失败离场。勋章（Badge）这个勋章可不只是一个荣誉的象征、身份的证明，累积勋章碎片合成勋章也能产生攻击加成。顺利击杀一名对手之后，你可以获得一枚勋章碎片。勋章对应所需勋章碎片数目以及攻击力加成如下：Badge numberAttack boostRequiredTotal125%22250%46375%8144100%16302 个勋章碎片可以提供 25% 的攻击力，6 个提升 50%，14 个提升 75%，30 个提升 100%。举个栗子：开局不久就杀了 6 个人，那么后面你只需要常规消除 6 行，也能给对手叠加 9 行方块。送砖（send lines）判定加成常规消除1行/2行/3行，分别会给对手发送0/1/2行；消除4行则会发送4行。遇上 Combo、Back to Back、Perfect Clear 等情况，还会有额外送砖加成。Line clearLines sentSingle0Double1Triple2Tetris4T-Spin Single2Mini T-Spin Single0T-Spin Double4Mini T-Spin Double1T-Spin Triple6Back-to-Back bonus+1All Clear bonus+4连击加成日版中显示为 ren，其他版本均显示为 combo。ComboLines sent0+01+12+13+24+25+36+37+48+49+410++5Target bonusOpponentsBonus lines sent2+13+34+55+76++9攻击生效时间【红色表示即将到攻击判定时间，灰色则是其他玩家刚对你进行攻击的层数】基本层面的防御：遭到攻击时出现的垃圾行，不是马上出现在盘面上的，而是出现在盘面左侧的区域，有一个冷却时间（见下图），在冷却时间结束前，防御者可以用攻击（消除行）来取消掉还没生效的攻击。攻击策略四种攻击模式分别对应R摇杆的四个方向。除此之外，你还可以通过左摇杆或者触屏，手动选择攻击对象。（但相信我，在紧急刺激的氛围之下，大多数人连 4 种模式都难以顾及切换，更别说点到点的针对性攻击了。）K.O. s 模式瞄准即将 game over 的玩家，是囤勋章的好法子，不过在前期可能效率不高。抢人头，补刀。Attackers 模式「谁打我，我打谁」，你的攻击会平均分配给所有瞄准你的对手，假如前期被集火，没有加成的情况下，比较难做出反杀。另外，在勋章加成下，选择 Badges 模式的人，也很容易被选择了 Attackers 的大神反杀。Randoms 模式也是开局时系统的默认模式。在发出攻击后，系统会切换到另一名随机玩家进行攻击。风险较小，不适合收割「人头」，大概相当于吃鸡游戏里的「苟」。Badges 模式瞄准勋章多的玩家进行攻击，击杀对手后可以获得对方拥有的勋章。前期囤勋章的人，到了后期很容易成为集火对象。判定https://www.bilibili.com/video/av43523518TETRIS用长柱形方块同时消4行则会触发TETRIS判定。1)在TOP等大部分Guideline方块中（下同），一次四行能直接给对方四个垃圾行，而一个三行只能给对方两个垃圾行，而且两次四行之间没有其他消行，还会额外多发送一个垃圾行（即Back to back）所以新手能做四行尽量做四行2)在效率方面，T-spin要比四行略胜一筹，前提是你会各种T-spin定式，定式见原帖【T-spin常见定式】tieba.baidu.com/p/12482566093）连击（日本称ren，其他版本为combo）为杀伤力最大的一种攻击方式，不过相比前面两种，更需要技术，常见的连击攻击方式为将左边/右边/中间（推荐中间保证自己不会被顶死），留下2/3/4格（分别称为2w、3w、4w）（w=width,宽度），其它地方尽量堆高，之后再把它们【不间断地】消除PS：按原帖所说，LPM不到60不要尝试在高手房搭连击T-Spin简而言之，我称其为“三面环绕的半十字”和”L型长廊”T旋转英文名为T-Spain，官方对T旋转的定义为最后一个操作为旋转，并且旋转后方块上下左右不能平移，成功消除即为T旋转。在3X3格的三个角落上必须被砖占据，可以参考下面图示：你需要确保有用于判定的三块砖：知道了T旋转的原理，那么离成功使用它就很近了。如果想要完成一个T旋转就要留下一个刚好能容下T形方块的空隙。根据判定标准我们还要让T形方块不能上下左右平移，所以需要在空隙的上面加一个“盖”。当成功构建好T旋转的架构后，只需要等待合适的方块落下，在最后一刻往正确防线旋转挤入空隙，就能完成牛X的T旋转了。在效率方面，T-spin要比四行略胜一筹，前提是你会各种T-spin定式，定式见原帖【T-spin常见定式】tieba.baidu.com/p/1248256609T-spin又有迷你、單行、雙行、三行Back to backT旋转不仅限T形方块，只要符合判定并且成功消除都为T旋转。在游戏中成功T旋转会有奖励，也就是能给对手更多层数的干扰方块。T旋转消除1行给对手2行干扰。消除2行则给与对手4行，消3行给6行。T旋转和4行消除（用长柱形方块同时消4行）称为是高级消除。连续达成高级消除还能触发Back-to-back，会在原本奖励上乘1.5。注意是两次消除，只要两次消除之间不间隔普通消除就能触发Back-to-back。所以现在明白为何自己总是受到成吨的伤害了吧。虽然学会了T旋转，但是不代表就能大杀四方，高收益意味着高风险。构建一个T旋转条件比较苛刻，而且一旦旋转时机没有掌握好留下的“烂尾楼”也很难消除。高手会利用现有的地形合理构建T旋转设置构建多重T旋转，而这个过程可能就需要长久的练习和丰富的经验了。成功道路没有捷径，就连玩游戏也是一样的。COMBO连击（日本称ren，其他版本为combo）为杀伤力最大的一种攻击方式，不过相比前面两种，更需要技术，常见的连击攻击方式为将左边/右边/中间（推荐中间保证自己不会被顶死），留下2/3/4格（分别称为2w、3w、4w）（w=width,宽度），其它地方尽量堆高，之后再把它们【不间断地】消除PS：按原帖所说，LPM不到60不要尝试在高手房搭连击Perfect Clear高端打法合理利用 L 键上面提到了，使用 L 键可以储存正在下落的方块。利用储存格的功能，配合可预知的 6 块方块，你可以试图进行不同的「战略规划」，例如 T-Spins 等。最简单的，你也可以存起一条万能竖块，在紧急情况下用来「救命」。合理切换击杀模式玩《绝地求生》时，很多人会根据游戏的进度，选择藏匿、抢物资、刚枪等操作，《俄罗斯方块 99》也同理。例如开局阶段，你可以选择不争不抢的随机模式，积累方块。预估可以造成一定输出后，选择击杀模式，囤一波勋章。或者是集火高手，抢夺物资。进入 50 人阶段后，调整为反击模式，对抗攻击你的对手。四列快消其次，《俄罗斯方块 99》在高手和小白玩家中，找到了合适的平衡点。《俄罗斯方块》的游戏下限和上限，都走向了两个极端。它很易上手，从学前班小朋友到公园大妈大爷，只要摸索一下就会玩。它极难精通，T-Spins、Back to Back……大神能向你展示有如建筑师一般的空间规划。来看一场神仙打架实录。但在过往的 30 多年，这两个玩家群体之间，仿佛有一道楚河汉界。休闲玩家偶尔玩玩用来消磨碎片时间，大神日练夜练创造纪录。所有人暴露在所有人的视野中，那么这里的”暴露“就是因你选择的攻击策略而定了攻击策略只是配菜，好的攻击策略会给你吸引集火、增加徽章（攻击力），但本质上还是需要的实打实的基础T-Spin就是爆头（增加伤害）真正的大佬都是打谁谁怀孕游戏体验极差焦虑对于菜鸟来说，焦虑来自于技术太菜反应太慢，眼看方块一摞一摞地叠高对不是自己所需要的掉落方块的无能狂怒被莫名其妙的一堆人莫名其妙的”爆头”攻击对何时选择何种攻击策略的迷茫眼看着左侧栏一堆攻击即将生效却束手无策对于大佬来说，焦虑来自于急于搜集勋章（对面怎么还不死？勋章为何迟迟不来？）不小心惹了大神，被大神按在地上锤（“这狗*怎么还不松口？”）进入50或10人决赛圈时的游戏节奏太快容易失误前期攒的勋章太多导致被众大佬集火，应接不暇只顾着消除群攻攻击而难以产生对他人的有效攻击而对于神级玩家来说，焦虑仅仅来自于：为什么对面这98人这么菜？为什么掉落速度这么慢？为什么这该死的攻击动画占用时间这么长？自己包围的群攻玩家不够多（”听着，你们98个人已经被我包围了！”）“这音游怎么只有这一个BGM？”��个BGM？”","link":"/QKS04c/"},{"title":"CSS实现下划线动画的各种姿势","text":"该文章还在施工中… 过几天再来看吧。在背景图片上做手脚思路就是 先让 background-image 限定在一定的高度，之后 :hover 时再用动画调整宽度。STEP1: background-image1234567891011.underline { background-image: linear-gradient(transparent calc(100% - 10px), black 10px); background-repeat: no-repeat; // 或者 background-image: linear-gradient(120deg, #7af7a9 0%, #FFEB3B 100%)； background-repeat: no-repeat; background-size: 100% 0.2em; background-position: 0 88%; // 或者 background-image: linear-gradient(transparent 0%, transparent 65%, yellow 65%, yellow 90%, transparent 90%, transparent);}STEP2:12345678.underline { background-size: 0% 100%; transition: background-size .3s ease-in; &amp;:hover { background-size: 100% 100%; }}在 border 上做手脚12345.underline { border-bottom: .4em solid transparent; border-image: linear-gradient(to right, #A8DBED 0%, #E291E6 100%); border-image-slice: 1;}使用伪元素12345678910111213141516171819h1 { position: relative; z-index: 0; &amp;::before { position: absolute; transition: .3s; content: ''; width: 0%; left: 0; bottom: 0; height: 16px; background: lightpink; z-index: -1; } &amp;:hover::before { width: 100%; }}使用阴影1234567891011121314.title .shadow { .is-red { box-shadow: inset 0 -6px 0 rgba(255,74,110,.2); } .is-turquoise { box-shadow: inset 0 -6px 0 rgba(35,209,153,.2); } .is-purple { box-shadow: inset 0 -6px 0 rgba(184,107,255,.2); } .is-yellow { box-shadow: inset 0 -6px 0 rgba(255,221,87,.2); }}","link":"/y0NIjj/"},{"title":"Splatoon全曲目收录歌单列表","text":"Splatoon2/喷射战士2 OST | 2019.2.20更新截至目前，歌单收藏量2949次，播放量109858次分享次数40次，评论50个 网易云音乐歌单地址介绍1~13 精选 Splatoon2 DLC 原声14~24 精选 同人曲25~47 同人曲专辑《Splatunes》48~71 ★ Splatoon2 DLC 原声72~92 ❤ Splatoon2 Live ❤93~101 精选 同人曲102~118 精选 Splatoon2 原声119~166 ★ Splatoon2 原声167~199 ★ Splatoon Live200~246 ❤ Splatoon1 原声 ❤247~283 同人曲284~335 ∎ Splatoon2 DLC, Splatoon2, Splatoon1 音效「喷射战士2」(Splatoon 2)是由任天堂游戏公司出版发行的第三人称射击类游戏，2017年7月21日独占登陆新主机NS。《喷射战士2》拥有1080P分辨率与60帧率的画面，与对新机能的“HD振动”的对应。玩家要在对战中展开 4 vs 4 的队伍战，使用各种各样的武器把对战场地的地面涂上我方队伍的颜色，占色面积多的队伍即可获得胜利。「喷射战士」是Nintendo(任天堂)制作发行的一款第三人称油彩动作射击类游戏；本作基本上采用4Vs4的方式进行战斗，也搭载了专供单人游戏的“英雄模式(ヒーローモード)”。该模式下玩家们需要为所属的军团战斗，并努力使己方变得更加壮大。2015年10月，获第33届金摇杆奖最佳家庭游戏。Tag：Nintendo Switch/WiiU/NS/任天堂/喷射乌贼娘2/潮色姐妹/喷射美少女2/死喷乱涂2/现场版/章鱼拓展包","link":"/ryAQ2R/"},{"title":"让JS实现Python的range函数","text":"🥓 有没有好的办法封装一个函数，让 js 支持类似 Python 内置的 range 函数呢？python 中有个内置函数叫 range()，一般和 for 循环搭配使用。range 函数很强大，正如其 API 文档 所阐述的：If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions. (如果你需要迭代一组数字，那么内置函数 range()就派上用场了。它能生成算术级数。) 使用了它，你就可以避免 for (var i=0; i&lt;length; i++) 的丑陋写法（裆然，性能吼不吼就另说了）你就可以转而使用 for-in, for-of, forEach 等优雅的写法。事不宜迟，让我们开始这篇水文吧！*注：不要把这里的 range 函数和 JavaScript DOM 的内置对象 Range 搞混。函数原型1range([start,]stop[,step]);参数说明：start: 计数从 start 开始。默认是从 0 开始。例如 range（5）等价于 range（0， 5）;stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有 5step：步长，默认为 1。例如：range（0， 5） 等价于 range(0, 5, 1)实现采用 Array.map()1const range = (start, end) =&gt; new Array(end - start).fill(start).map((el, i) =&gt; start + i);利用 Array.keys()1[...Array(n).keys()];其实就等效为1Array.from(Array(n).keys());利用生成器（yield）12345const range = function*(start = 0, stop, step = 1) { let cur = stop === undefined ? 0 : start; let max = stop === undefined ? start : stop; for (let i = cur; step &lt; 0 ? i &gt; max : i &lt; max; i += step) yield i;};加上参数数目和类型的判断，以便用于生产环境。1234567891011121314151617181920212223242526272829303132333435363738394041function* range(a, b, step) { switch (arguments.length) { case 0: return; case 1: b = Number(a); a = 0; step = 1; break; case 2: a = Number(a); b = Number(b); step = a &lt; b ? +1 : -1; break; case 3: a = Number(a); b = Number(b); step = Number(step); break; } if (Number.isNaN(a) || Number.isNaN(b) || Number.isNaN(step)) return; if (a === b || !step) return; if (a &lt; b) { if (step &lt; 0) return; while (a &lt; b) { yield a; a += step; } } if (a &gt; b) { if (step &gt; 0) return; while (a &gt; b) { yield a; a += step; } }}12345678910111213141516171819202122232425262728293031/** * 生成迭代器 * @param {Number} start 开始值 * @param {Number} end 结束值 * @param {Number} step 步长 * @yield {Generator} 迭代器 */function* range(start = 0, end = 0, step = 1) { if (start &gt; end) { [start, end] = [end, start]; } for (let i of Array((end - start) / step).keys()) { yield i * step + start; }}// Generate range from start (inclusive) to stop (exclusive):function* range(start, stop, step = 1) { if (stop === undefined) [start, stop] = [0, start]; if (step &gt; 0) while (start &lt; stop) yield start, (start += step); else if (step &lt; 0) while (start &gt; stop) yield start, (start += step); else throw new RangeError(\"range() step argument invalid\");}// Examples:console.log([...range(3)]); // [0, 1, 2]console.log([...range(0, 3)]); // [0, 1, 2]console.log([...range(0, 3, -1)]); // []console.log([...range(0, 0)]); // []console.log([...range(-3)]); // []console.log([...range(-3, 0)]); // [-3, -2, -1]普通 for 循环写法123456789function range(start, end, step) { let arr = []; for (let i = start; i &lt; end; i++) { if (i % step == 0) { arr.push(i); } } return arr;}也可以绑定到 Array 原型上123456789Object.defineProperty(Array.prototype, \"range\", { value: function(start, end) { this.length = end - start; for (var i = 0; i &lt; this.length; i++) { this[i] = start + i; } }, enumberable: false});Example12var arr = new Array();console.log(arr.range(0, 3)); //[0,1,2]利用 Array.from()12const initializeArrayWithRange = (start = 0, end = 0, step = 1) =&gt; Array.from({ length: Math.ceil((end - start + 1) / step) }, (v, i) =&gt; i * step + start);Examples123initializeArrayWithRange(5); // [0,1,2,3,4,5]initializeArrayWithRange(7, 3); // [3,4,5,6,7]initializeArrayWithRange(9, 0, 2); // [0,2,4,6,8]还可以以此实现整数列表倒序的写法.1234const initializeArrayWithRangeRight = (end, start = 0, step = 1) =&gt; Array.from({ length: Math.ceil((end + 1 - start) / step) }).map( (v, i, arr) =&gt; (arr.length - i - 1) * step + start );Examples123initializeArrayWithRangeRight(5); // [5,4,3,2,1,0]initializeArrayWithRangeRight(7, 3); // [7,6,5,4,3]initializeArrayWithRangeRight(9, 0, 2); // [8,6,4,2,0]lodash 库的方案以上面这种遍历数组的思路，lodash 库的 baseRange.js 提供了最佳方案：12345678910111213141516171819202122/** * The base implementation of `range` and `rangeRight` which doesn't * coerce arguments. * * @private * @param {number} start The start of the range. * @param {number} end The end of the range. * @param {number} step The value to increment or decrement by. * @param {boolean} [fromRight] Specify iterating from right to left. * @returns {Array} Returns the range of numbers. */function baseRange(start, end, step, fromRight) { let index = -1; let length = Math.max(Math.ceil((end - start) / (step || 1)), 0); const result = new Array(length); while (length--) { result[fromRight ? length : ++index] = start; start += step; } return result;}Underscore 库的方案123456789101112131415161718192021// Generate an integer Array containing an arithmetic progression. A port of// the native Python `range()` function. See// [the Python documentation](http://docs.python.org/library/functions.html#range)._.range = function(start, stop, step) { if (stop == null) { stop = start || 0; start = 0; } if (!step) { step = stop &lt; start ? -1 : 1; } var length = Math.max(Math.ceil((stop - start) / step), 0); var range = Array(length); for (var idx = 0; idx &lt; length; idx++, start += step) { range[idx] = start; } return range;};Example12345678910_.range(10);=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]_.range(1, 11);=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]_.range(0, 30, 5);=&gt; [0, 5, 10, 15, 20, 25]_.range(0, -10, -1);=&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]_.range(0);=&gt; []另一种 ES6 写法123456789const range = (from, to, step = 1) =&gt; { //swap values if necesery [from, to] = from &gt; to ? [to, from] : [from, to]; //create range array return [...Array(Math.round((to - from) / step))].map((_, index) =&gt; { const negative = from &lt; 0 ? Math.abs(from) : 0; return index &lt; negative ? from + index * step : (index - negative + 1) * step; });};Example12345range(-20, 0, 5).forEach(val =&gt; console.log(val));for (const val of range(5, 1)) { console.log(`value ${val}`);}log(value ${val});}12","link":"/tuDhTb/"},{"title":"星之卡比全曲目收录歌单列表","text":"星之卡比/Kirby BGM | 2018.11.27 更新截至目前，歌单收藏量2199次，播放量100924次分享次数25次，评论108个 网易云音乐歌单地址介绍时隔8个月再次更新歌单!!!~星之卡比每一首曲子都是一个masterpiece。卡比酱真的好可爱！Nintendo/任天堂 wiiu/wii/3ds/nds/gba 卡通/游戏背景音乐/日本/轻音乐/原声大碟/萌萌哒/经典/回忆/90后/00后/11区/收集向/全站最全/可爱/星のカービィ","link":"/v8o7kd/"},{"title":"从零开始的Hexo博客搭建教程（六）：插件","text":"👓 推荐常用的 Hexo 插件 : Awesome-hexo-plugins如果你有好的插件推荐，欢迎在评论区分享喔 ο(=•ω ＜=)ρ⌒☆文章hexo-auto-category 根据文件目录自动生成文章分类最常用的文件管理策略，就是利用文件系统目录结构(树形结构 directory-tree)。同样，为了便于管理大量的日志文件，采用目录结构是一种简便可行的方案。hexo-auto-category 根据日志文件(Markdown)所在文件目录自动分类，即自动生成markdown的front-matter中的categories变量。1$ npm install hexo-auto-category --save示例对于博客 source/_post/web/framework/hexo.md，该插件会自动生成以下categories123categories: - web - framework配置在站点根目录下的_config.yml添加：123auto_category: enable: true depth: 1 #生成到第几级目录分类hexo-renderer-markdown-it 使用 markdown-it 作渲染器1$ npm install hexo-renderer-markdown-it --savehexo-related-popular-posts 生成相关热门文章列表该插件会根据文章指定的 tags 生成一系列的相关文章列表，所以发布文章请务必在 Front Matter 中指定 tags。1$ npm install hexo-related-popular-posts --save安装该插件后需要DIY你的主题First, add the following popular_posts( {} , post ) helper tag in template file for article. For example , if you use hexo-theme-landscape , add a tag here.123&lt;%- popular_posts( {} , post )%&gt;更多详细文档请移步 tea3/hexo-related-popular-posts 查阅。hexo-description 根据标记位置自动生成文章简介If post has no description set, will auto use excerpt as description.1npm install hexo-description --save之后在文章中标记 &lt;!--more--&gt; 标签即可。流程Origin post12345678---title: Example post---## excerpt- list1- list2&lt;!-- more --&gt;contentOrigin excerpt123## excerpt- list1- list2Rendered excerpt123&lt;h2&gt;excerpt&lt;/h2&gt;&lt;li&gt;list1&lt;/li&gt;&lt;li&gt;list2&lt;/li&gt;Finally we set pure excerpt text to description1excerptlist1list2SEOhexo-baidu-url-submit 向百度主动提交链接主动推送Hexo博客新链接至百度搜索引擎，解决百度爬虫被禁止访问的问题，提升网站收录质量和速度。1npm install hexo-baidu-url-submit --save把以下内容配置到_config.yml文件中:12345baidu_url_submit: count: 1 ## 提交最新的一个链接 host: www.nuist.today ## 在百度站长平台中注册的域名 token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里其次，记得查看_config.ym文件中url的值， 必须包含是百度站长平台注册的域名（一般有www）， 比如:1234# URLurl: https://www.nuist.todayroot: /permalink: p/:title/最后，加入新的deployer:12deploy:- type: baidu_url_submitter # 百度执行hexo deploy的时候，新的连接就会被推送了。支持熊掌号12345678baidu_url_submit: count: 1000 ## 提交最新的一个链接 host: alili.tech ## 在百度站长平台中注册的域名 token: xxxxx ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里 xz_appid: 'xxxxxx' ## 你的熊掌号 appid xz_token: 'xxxxxx' ## 你的熊掌号 token xz_count: 10 ## 从所有的提交的数据当中选取最新的10条,该数量跟你的熊掌号而定加入新的 deployer 即可12deploy:- type: baidu_xz_url_submitter # 百度熊掌号hexo-autonofollow 外链自动 nofollow1$ npm install hexo-autonofollow --save注：hexo-nofollow 插件实在是让我头大，使用后会导致页面中多出许多莫名其妙的 &lt;meta name=generator content=&quot;Hexo 3.8.0&quot;&gt;，扰乱了博客页面排版。我又一步步重新搭了一遍博客排查错误，最终发现 package.json 中删除 &quot;hexo-nofollow&quot;: &quot;^1.0.5&quot;, 即可完美解决问题。hexo-seo-link-visualizer 分析链接并可视化站点结构1$ npm install hexo-seo-link-visualizer --saveUsageFirst of all , you should to add npm script. Please insert as follow code at package.json.123\"scripts\": { \"show-article-map\": \"node node_modules/hexo-seo-link-visualizer/app/show-article-map.js\"},Next , Please run server and excute npm script. ($ hexo clean be sure to run.)123$ hexo clean$ hexo server$ npm run show-article-mapLast , Please run server of link visualizer. Since the default URL is localhost:1234, open this URL.OptionsYou can change plugin settings with as follow option. Please edit _config.yml.1234567891011121314151617# hexo-seo-link-visualizer's optionseoLinkVisualizer: enable: true cache: cache/seo-link-visualizer.json port: 1234 previewHost: localhost:4000/ categoryDepthLimits: 1 allowedSourcePath: - _posts/ # - _drafts ignoreLink: int: ext: - amazon - amz - flickr toc:hexo-baidu-url-push 百度站长平台自动推送工具⚠ 该插件使用后会出现以下BUG：ReferenceError: path is not defined一个hexo插件，使用百度JS链路自动推送方法，提交链接到百度自动推送是百度站长平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。1npm install hexo-baidu-url-push --save其实就是向页面追加了以下代码1234567891011121314&lt;script&gt;(function(){ var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') { bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; } else { bp.src = 'http://push.zhanzhang.baidu.com/push.js'; } var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);})();&lt;/script&gt;生成器hexo-generator-topindex 置顶文章1$ npm install hexo-generator-topindex --save配置123topindex_generator: per_page: 10 #Posts displayed per page. (0 = disable pagination) order_by: -date #Posts order. (Order by date descending by default)使用方法这样，就可以在文章的 Front Matter 中指定 top: 数字 实现文章置顶效果了。hexo-generator-feed 生成博客 RSS1$ npm install hexo-generator-feed --saveYou can configure this plugin in _config.yml.12345678910feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: \" \" order_by: -date icon: icon.png使用方法In the front-matter of your post, you can optionally add a description, intro or excerpt setting to write a summary for the post. Otherwise the summary will default to the excerpt or the first 140 characters of the post.hexo-generator-sitemap 生成 sitemap.xml1$ npm install hexo-generator-sitemap --savehexo-generator-baidu-sitemap 生成 baidusitemap.xml1$ npm install hexo-generator-baidu-sitemap --save工具hexo-abbrlink 生成文章唯一ID1$ npm install hexo-autonofollow --savehexo-nanoid 用 nanoid 生成文章唯一ID1$ npm install hexo-nanoid --savehexo-translate-title 将汉字标题转成英文标题安装1npm install hexo-translate-title --save使用1.配置hexo根项目下的_config.yml12345678translate_title: translate_way: google # google,youdao,baidu_with_appid,baidu_no_appid youdao_api_key: '' # Your youdao_api_key youdao_keyfrom: xxxx-blog # Your youdao_keyfrom is_need_proxy: false # true | false proxy_url: http://localhost:50018 # Your proxy_url baidu_appid: '' # Your baidu_appid baidu_appkey: '' # Your baidu_appkey注意判断是否需要配置google本地代理，因为我在本地是开启时才能访问google翻译的，如果没有被墙，请将_config.yml 下的is_need_proxy: true改为false。如果设置为true,请设置本地代理地址目前google翻译，youdao翻译均可直接使用，百度翻译使用APPID版本，无APPID版本均已完成，APPID版本需要在百度翻译开放平台如果担心百度翻译开发平台的APP_ID和APP_KEY有泄漏风险，建议在百度翻译开发平台-》管理控制台的服务器地址一栏，填写好服务器IP即可2.修改hexo根目录下的_config.yml修改permalink: :year/:month:day/:translate_title.html将:title修改为:translate_title即可，前面的路径也可按照自己的要求变更，例如 permalink: blog/:translate_title.htmlhexo-all-minifier 压缩所有静态文件支持压缩 HTML、CSS、JS、图片，支持打包js，平均耗时20s，功能强大简单易用。1$ npm install hexo-all-minifier --saveJust put this line in the config file of your hexo-site to enable this plugin.1all_minifier: trueIf you need futher control of this plugin, please refer the options below.123456789101112131415161718192021222324252627282930313233343536js_concator: enable: false #Enable the Js concator. Defaults to `false`. bundle_path: '/js/bundle.js' #The output path of the bundle script. It will be set as absolute path to the root dir. front: false #Put the bundle script in the front of all scripts in body tag. Default to false, which means the bundle script will be placed in the back of other scripts. silent: false #Disable logging optimize informations. Defaults to `false`. html_minifier: enable: true #Enable the HTML minifier. Defaults to `true`. ignore_error: false #Ignore the error occurred on parsing html. silent: false #Disable logging optimize informations. Defaults to `false`. exclude: #Exclude files. Glob is support. css_minifier: enable: true #Enable the CSS minifier. Defaults to `true`. silent: false #Disable logging optimize informations. Defaults to `false`. exclude: #Exclude files. Glob is support. - '*.min.css' js_minifier: enable: true #Enable the JS minifier. Defaults to true. mangle: true #Mangle file names silent: false #Disable logging optimize informations. Defaults to `false`. output: #Output options. If it is empty, please remove it from the .yml file! Otherwise it will be set to `null`, which is different from `undefined`. compress: #Compress options. If it is empty, please remove it from the .yml file! Otherwise it will be set to `null`, which is different from `undefined`. exclude: - '*.min.js' image_minifier: enable: true #Enable the image minifier. Defaults to `true`. interlaced: false #Interlace gif for progressive rendering. Defaults to `false`. multipass: false #Optimize svg multiple times until it’s fully optimized. Defaults to `false`. optimizationLevel: 2 #Select an optimization level between 0 and 7. Defaults to `2`. pngquant: false #Enable imagemin-pngquant plugin. Defaults to false. progressive: false #Lossless conversion to progressive. Defaults to false. silent: false #Disable logging optimize informations. Defaults to false. exclude: #Exclude specific types of image files, the input value could be gif,jpg, png, or svg. Default to null. Glob is not support.hexo-pwa 支持PWAhexo-pwa 使得 Hexo 站点将支持以下特性：Web App Manifest - Users can add your site to mobile home screenService Worker - Make your site available offline1$ npm install --save hexo-pwa配置You can configure this plugin in _config.yml.1234567891011121314151617181920212223242526272829303132pwa: manifest: path: /manifest.json body: name: hexo short_name: hexo icons: - src: /images/android-chrome-192x192.png sizes: 192x192 type: image/png - src: /images/android-chrome-512x512.png sizes: 512x512 type: image/png theme_color: '#ffffff' background_color: '#ffffff' display: standalone serviceWorker: path: /sw.js preload: urls: - / posts: 5 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /.*\\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\\// strategy: networkFirst priority: 5manifest - manifest configurationpath - the path of manifest.json, eg: /manifest.jsonbody - the content of manifest.json, manifest.json example. body can be null, if not null, hexo-pwa will generate manifest.json with JSON.stringify(body)serviceWorker - service worker configurationpath: the path of sw.js, eg: /sw.js, you shouldn’t put sw.js in subdirectory because of the service worker scopepreload - urls or posts that you want to preloadurls: an array of the preload urlsposts: the count of preload postsopts: the options for sw-toolboxroutes - request routes and strategies, based on sw-toolbox. The routes order does matter.pattern: url pattern, this config can be express-style or RegExpstrategy: the strategy you want to choose. All strategies: cacheFirst, networkFirst, cacheOnly, networkOnly, fastest. Caution: Log requests should use networkOnly strategy.priority - plugin priority (default value is 10)hexo-lazyload-image 图片懒加载1$ npm install hexo-lazyload-image --save使用First add configuration in _config.yml from your hexo project.1234lazyload: enable: true onlypost: false loadingImg: # eg ./images/loading.gif标签拓展💡 温馨提示为方便未来可能的数据迁移，建议少用独有 markdown 语法。并且 许多上古插件早已过时，作者已不再维护，极容易出现类似 DeprecationWarning: fs.SyncWriteStream is deprecated 等的问题。其次，建议使用 hexo-renderer-markdown-it 作为 markdown 渲染器，功能强大，高效渲染。它可以将 markdown-it 的一套通用的生态体系带到 Hexo 上来。如果你觉得这些都不是问题，那么，开始 enjoy 吧！👇hexo-codepen-v2 插入 Codepen 代码片段1npm install hexo-codepen-v2 --saveUsageCreate Embedded Pen with following syntax:1{% codepen slugHash default_tabs height width userId|anonymous|anon theme %}How to get arguments from CodePen embedThis is something generated by CodePen:12&lt;p data-height=\"300\" data-theme-id=\"33713\" data-slug-hash=\"mKEmpj\" data-default-tab=\"html,result\" data-user=\"yuanchuan\" data-embed-version=\"2\" data-pen-title=\"Flow #1\" class=\"codepen\"&gt;See the Pen &lt;a href=\"https://codepen.io/yuanchuan/pen/mKEmpj/\"&gt;Flow #1&lt;/a&gt; by yuanchuan (&lt;a href=\"https://codepen.io/yuanchuan\"&gt;@yuanchuan&lt;/a&gt;) on &lt;a href=\"https://codepen.io\"&gt;CodePen&lt;/a&gt;.&lt;/p&gt;&lt;script async src=\"https://static.codepen.io/assets/embed/ei.js\"&gt;&lt;/script&gt;You can extract required arguments:FieldValueuserIdyuanchuanslugHashmKEmpjtheme33713default_tabshtml,resultheight300widthThis value should be adjusted according to your blog theme, by default it is 100%All of this settings except for slugHash can be set in _config.yml under codepen property.123456codepen: userId: \"yuanchuan\" theme: \"33713\" default_tabs: \"js,result\" height: 500 width: \"100%\"hexo-tag-kbd 支持 kbd 标签1npm install hexo-tag-kbd --save用例12{% kbd Ctrl %} + {% kbd A %}{% kbd Ctrl %} + {% kbd ALT %} + {% kbd DELETE %}几个特殊按键EnterShiftCommandOptionhexo-tag-color-block 颜色标签1npm i hexo-tag-color-block使用方法The full tag format is as follows:1{% colorblock [color hex code] [width] [height] %}Example:1{% colorblock #f8dcf8 %}额外配置请访问 https://github.com/patrick330602/hexo-tag-color-block#configurationhexo-tag-hint1$ npm install hexo-tag-hint --saveUsage1{% hint &apos;body_text&apos; &apos;hint_text&apos; %}hexo-tag-bilibili 插入bilibili视频1npm install --save hexo-tag-bilibiliUsageThe full tag format is as follows:123{% bilibili [av_id] %}or{% bilibili [av_id] [page] %}example:1{% bilibili 2333333 3 %}hexo-ruby-character Ruby character tagRuby character tag for Hexo, inspired by the Ruby template of 萌娘百科.1npm install hexo-ruby-character --saveUsage1{% ruby Base|top %}→ Base (top)Specifically, if the top field is in Chinese characters, it while be converted to Chinese pinyin, because the pinyin chatater with heads are not easy to type.Followings are the examples.1{% ruby 佐天泪子|掀裙狂魔 %}→ 佐天泪子 (xiān qún kuáng mó)Other languages like Japanese is also supported.1{% ruby 超電磁砲|レールガン %}→ 超電磁砲 (レールガン)hexo-github-card GitHub 用户资料卡片Display a card for GitHub profile and repo in your hexo blog. Implemented with Github-cards.1npm install --save hexo-github-cardUsageInsert githubCard tag in your article:1{% githubCard user:your_user [repo:your_repo] [width:400] [theme:Default] [client_id:your_client_id] [client_secret:your_client_secret] [align:text-align_position] %}ArgumentDescriptionuserGitHub user namerepo(Optional) GitHub repository name of the user. If omit then display only the user profilewidth(Optional) Widget’s width. It should be a valid CSS width value. Default is 400.client_id(Optional) Your GitHub app client_idclient_secret(Optional) Your GitHub app client_secretalign(Optional) What kind of text-align is you want. Default is center.(Configuration are consistent with github-cards)Example:Display user profile only1{% githubCard user:Gisonrg %}Display a repo1{% githubCard user:Gisonrg repo:hexo-github-card %}hexo-caniuse Can I Use CSS Features?1$ npm install hexo-caniuse --saveUsageCreate The CanIUse Embed with following syntax:1{% caniuse feature periods|current %}How to get arguments from caniuse embedThis is something generated by caniuse:1234&lt;p class=\"ciu_embed\" data-feature=\"css-variables\" data-periods=\"current\"&gt; &lt;a href=\"http://caniuse.com/#feat=css-variables\"&gt;Can I Use css-variables?&lt;/a&gt; Data on support for the css-variables feature across the major browsers from caniuse.com.&lt;/p&gt;&lt;script async src=\"//cdn.jsdelivr.net/caniuse-embed/1.1.0/caniuse-embed.min.js\"&gt;&lt;/script&gt;You can extract required arguments:FieldValuedata-featureChoose caniuse Feature featuredata-periodsSelect the Browser Versions to Displayhexo-github 追踪 GitHub 仓库 commit1npm install --save hexo-github使用方法Insert github tag in your article:1{% github user repo referenced_commit [auto_expand = true | false] [width = 100%] %}ArgumentDescriptionuserGitHub user namerepoGitHub repository name of that usercommitCommit sha1 referenced in the articleauto_expand(Optional, default == false) true of false. Expand the timeline once synced if set to true.width(Optional, default == 100%). Widget’s width. It should be a valid CSS width value.例子1{% github akfish hexo-math b82e65 %}部署hexo-deployer-git 部署到 Git1$ npm install hexo-deployer-git --save配置You can configure this plugin in _config.yml.12345678910111213141516171819202122232425262728# You can use this:deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] name: [git user] email: [git email] extend_dirs: [extend directory] ignore_hidden: false # default is true ignore_pattern: regexp # whatever file that matches the regexp will be ignored when deploying# or this:deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] coding: &lt;repository url&gt;,[branch] extend_dirs: - [extend directory] - [another extend directory] ignore_hidden: public: false [extend directory]: true [another extend directory]: false ignore_pattern: [folder]: regexp # or you could specify the ignore_pattern under a certain directory美化hexo-helper-live2d 萌萌哒二次元看板娘向你的Hexo里放上一只萌萌哒二次元看板娘!演示: https://l2dwidget.js.org/dev.html原作大大的博客: https://huaji8.top/post/live2d-plugin-2.0/1npm install --save hexo-helper-live2d详细配置过多，请查看 https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md📘《从零开始的Hexo博客搭建教程》系列文章：从零开始的Hexo博客搭建教程（一）：开始从零开始的Hexo博客搭建教程（二）：主题从零开始的Hexo博客搭建教程（三）：SEO优化从零开始的Hexo博客搭建教程（四）：图床从零开始的Hexo博客搭建教程（五）：文章发布从零开始的Hexo博客搭建教程（六）：插件从零开始的Hexo博客搭建教程（七）：遇到的坑","link":"/hAbX6u/"},{"title":"【译】一张图搞定CSS选择器知识","text":"原文：CSS selectors cheatsheet &amp; details作者：nana Jeon 译者：gylidian📜 CSS selectors cheatsheet这些天，我一直在折腾 CSS 选择器。拥有杂七杂八符号的 CSS 选择器太多了，比如 > . , * + ~ [] 等等，因此我经常被如何使用这些选择器搞得头大。终于，我把它们在我脑海中理顺了，并按照我的理解来构建知识体系。*事实上，为了节省纸张、保护地球，我原本是想把它们全部只放在一张 A4 大小的页面上，但因为有太多的选择器我想添加，所以我不得不做成多页。除了封面外，其余四页都是 A4 的。把这张纸打印出来，贴在墙上，别刻意去记，只是用来没事儿偷瞄几眼而已。我希望这张 cheatsheet 能帮助你快速找到合适的 CSS 选择器并节省时间。🔮 来！下载 CSS selectors cheatsheet.pdf 吧！然后玩玩 这个游戏🕹！CSS Selectors Cheatsheet - FrontEnd30&gt;&nbsp;.&nbsp;, + ~&nbsp;: { } ( ) [ ] ID is not recommended as a selector Combine the Class Selector: b.x { } First Child Pseudo…frontend30.com🔎 Dive into CSS selector.我会列出图表和来自 MDN 的标准定义，使得这些知识更容易理解。元素选择器CSS 元素选择器(也称为类型选择器)通过 node 节点名称匹配元素. 因此,在单独使用时,寻找特定类型的元素时,元素选择器都会匹配该文档中所有此类型的元素. - MDNID 选择器在一个 HTML 文档中,CSS ID 选择器会根据该元素的 ID 属性中的内容匹配元素,元素 ID 属性名必须与选择器中的 ID 属性名完全匹配，此条样式声明才会生效。 - MDN后代选择器当使用 ␣ 选择符 (这里代表一个空格,更确切的说是一个或多个的空白字符) 连接两个元素时使得该选择器可以只匹配那些由第一个元素作为祖先元素的所有第二个元素(后代元素) . 后代选择器与 子选择器 很相似, 但是后代选择器不需要相匹配元素之间要有严格的父子关系. - MDN组合使用后代选择器和 ID 选择器类选择器在一个 HTML 文档中，CSS 类选择器会根据元素的类属性中的内容匹配元素。类属性被定义为一个以空格分隔的列表项，在这组类名中，必须有一项与类选择器中的类名完全匹配，此条样式声明才会生效。 - MDN组合使用类选择器组合器和多个选择器组合器和选择器组 — 将多个选择器组合在一起以进一步利用其选择能力的两种方式。 - MDN通配选择器在 CSS 中,一个星号(*)就是一个通配选择器.它可以匹配任意类型的 HTML 元素.在配合其他简单选择器的时候,省略掉通配选择器会有同样的效果.比如,*.warning 和.warning 的效果完全相同. - MDN组合使用通配选择器相邻兄弟选择器相邻兄弟选择器 (+) 介于两个选择器之间，当第二个元素紧跟在第一个元素之后，并且两个元素都是属于同一个父元素的子元素，则第二个元素将被选中。 - MDN通用兄弟选择器在使用 ~ 连接两个元素时,它会匹配第二个元素,条件是它必须跟(不一定是紧跟)在第一个元素之后,且他们都有一个共同的父元素 . - MDN子选择器当使用 &gt; 选择符分隔两个元素时,它只会匹配那些作为第一个元素的直接后代(子元素)的第二元素. 与之相比, 当两个元素由 后代选择器 相连时, 它表示匹配存在的所有由第一个元素作为祖先元素(但不一定是父元素)的第二个元素, 无论它在 DOM 中”跳跃” 多少次. - MDN:first-child:first-child CSS pseudo-class 表示在一组兄弟元素中的第一个元素。 - MDN:only-childCSS伪类:only-child代表了属于某个父元素的唯一一个子元素.等效的选择器还可以写成 :first-child:last-child或者:nth-child(1):nth-last-child(1),当然,前者的权重会低一点. - MDN:last-child:last-child` CSS 伪类 代表父元素的最后一个子元素。 - MDN:nth-child:nth-child(an+b) 这个 CSS 伪类首先找到所有当前元素的子元素，然后按照位置先后顺序从 1 开始排序，选择的结果为第（an+b）个元素的集合（n=0，1，2，3…）。 - MDN:nth-last-child:nth-last-child(an+b) 这个 CSS 伪类匹配文档树中在其之后具有 *a*n+*b*-1 个兄弟节点的元素，其中 n 为正值或零值。它基本上和 :nth-child 一样，只是它从结尾处反序计数，而不是从开头处。 - MDN:first-of-typeCSS 伪类 :first-of-type表示一组兄弟元素中其类型的第一个元素。 - MDN:nth-of-type:nth-of-type() 这个 CSS 伪类匹配文档树中在其之前具有 *a*n+*b*-1 个相同兄弟节点的元素，其中 n 为正值或零值。简单点说就是，这个选择器匹配那些在相同兄弟节点中的位置与模式 an+b 匹配的相同元素。 - MDN1234567🔮 Note::nth-of-type(even):nth-of-type(odd):nth-of-type(2):nth-of-type(2n):nth-of-type(3n-1):nth-of-type(2n+2):only-of-typeCSS 伪类 :only-of-type 代表了任意一个元素，这个元素没有其他相同类型的兄弟元素。 - MDN附上 :only-child 和 :only-of-type 的对比：:last-of-type:last-of-type CSS 伪类 表示了在（它父元素的）子元素列表中，最后一个给定类型的元素。当代码类似 Parent tagName:last-of-type 的作用区域包含父元素的所有子元素中的最后一个选定元素，也包括子元素的最后一个子元素并以此类推。 - MDN:empty:empty CSS 伪类 代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）。注释或处理指令都不会产生影响。 - MDN:not()CSS 否定伪类，:not(X)，是以一个简单的以选择器 X 为参数的功能性标记函数。它匹配不符合参数选择器 X 描述的元素。X 不能包含另外一个否定选择器。:not 伪类的优先级即为它参数选择器的优先级。:not 伪类不像其它伪类，它不会增加选择器的优先级。 - MDN属性选择器属性选择器是一种特殊类型的选择器，它根据元素的 属性 和属性值来匹配元素。它们的通用语法由方括号 ([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： 存在和值属性选择器和子串值属性选择器。 - MDN存在属性选择器值属性选择器子串值属性选择器这种情况的属性选择器也被称为“伪正则选择器”，因为它们提供类似 regular expression 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）- MDN[attr^=val]选择 attr 属性的值以 val 开头（包括 val）的元素。[attr$=val]选择 attr 属性的值以 val 结尾（包括 val）的元素。[attr*=val]选择 attr 属性的值中包含子字符串 val 的元素（一个子字符串就是一个字符串的一部分而已，例如，”cat“ 是 字符串 ”caterpillar“ 的子字符串）。🎉 （完） 🎉📖 参考文章https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectorshttps://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Combinators_and_multiple_selectorshttps://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classeshttps://css-tricks.com/almanac/selectors/🕹 CodePen来来来，看这里 👉 https://codepen.io/nana8/pen/aXQgoj","link":"/ejIjWE/"},{"title":"2018年我的代码行数年度总结","text":"2018 年 年度总结 代码行数统计工具npm install -g sloc统计内容Create stats of the source code:physical lineslines of code (source)lines with commentslines with single-line commentslines with block commentslines mixed up with source and commentsempty lines within block commentsempty lineslines with TODO’s使用方法sloc --details --format json --exclude node_modules ./sloc --exclude node_modules ./统计结果D:\\部署在线上的网站\\Hackathonhtml css javascript杭电黑客松作品的前端部分，废弃许久未动。当时熬了踏马 18 个小时写了个 webapp，虽然很简陋但是动画很骚，音乐也能正确获取、记录、播放 就是了123456789101112131415---------- Result ------------ Physical : 23867 Source : 19319 Comment : 3054 Single-line comment : 675 Block comment : 2379 Mixed : 122 Empty block comment : 2 Empty : 1618 To Do : 0Number of files read : 19----------------------------D:\\部署在线上的网站\\Noveltyhtml css javascript17 年（好像是年底）和学长参赛写过的一款物联网家庭控制面板，18 年一直修缮中。主要是 UI 一直在精心打磨，也重构过两次 js 代码（后来看了学长给的 es6 书就用上了很多骚操作）这也是我第一次使用 MDUI 这个框架123456789101112131415---------- Result ------------ Physical : 49094 Source : 37906 Comment : 6605 Single-line comment : 1356 Block comment : 5250 Mixed : 203 Empty block comment : 6 Empty : 4792 To Do : 1Number of files read : 37----------------------------D:\\部署在线上的网站\\NUIST 大赛官网html scss javascript svg参加校 UI 竞赛的参赛作品，其实是 17 年(๑•̀ㅂ•́)و✧ 帮一个学姐(好朋友)写过的 web 课设，但是后来熬夜 10 天加了许多页面和装逼特效。123456789101112131415---------- Result ------------ Physical : 42310 Source : 32977 Comment : 3424 Single-line comment : 1553 Block comment : 1871 Mixed : 269 Empty block comment : 6 Empty : 6184 To Do : 2Number of files read : 154----------------------------D:\\部署在线上的网站\\Ruffhtml css javascript去交大黑客松写的作品大概是菜鸡第一次尝试全栈吧（前端、后端、硬件其实那时候 nodejs 还不怎么会，就在这次写后端和写硬件的过程中，踩了不少坑就会用 Express 写 API 了然后 ruff 这个阉割版的 node 引擎一般般吧，当时用起来觉得巨他妈爽，后来就抛弃了 ruff123456789101112131415---------- Result ------------ Physical : 51890 Source : 40354 Comment : 6760 Single-line comment : 1390 Block comment : 5371 Mixed : 204 Empty block comment : 3 Empty : 4983 To Do : 2Number of files read : 71----------------------------D:\\部署在线上的网站\\简历html css javascript暑假找人 py 交易去小公司实习用的装逼页面123456789101112131415---------- Result ------------ Physical : 2855 Source : 2232 Comment : 342 Single-line comment : 69 Block comment : 273 Mixed : 21 Empty block comment : 5 Empty : 307 To Do : 12Number of files read : 16----------------------------D:\\NodeJs\\nuistbotnode最近一个月写的 cqhttp 机器人，一直在熬夜修缮之前刚用 seesion 做出了 表单（Progressive Forms）功能也写了 只能发一张图片的说说 的 空间机器人（只能发说说算什么机器人啊喂1234567891011121314151617181920212223242526272829303132333435PS D:\\NodeJs\\nuistbot&gt; sloc src/---------- Result ------------ Physical : 2384 Source : 1481 Comment : 794 Single-line comment : 162 Block comment : 632 Mixed : 35 Empty block comment : 5 Empty : 149 To Do : 1Number of files read : 39----------------------------PS D:\\NodeJs\\nuistbot&gt; sloc bin/---------- Result ------------ Physical : 154 Source : 115 Comment : 18 Single-line comment : 18 Block comment : 0 Mixed : 9 Empty block comment : 0 Empty : 30 To Do : 0Number of files read : 4----------------------------D:\\NodeJs\\star-codepen-managementnode html css javascript vue因为天天刷 codepen，collection 已经多到爆了，我的 star 数量起码 6000 了，迫不得已写了个浏览器拓展，有待开源（其实我是想写 electron 的，但是菜得很，electron 还没学懂）1234567891011121314151617PS D:\\NodeJs\\star-codepen-management&gt; sloc src/---------- Result ------------ Physical : 9327 Source : 7783 Comment : 508 Single-line comment : 208 Block comment : 300 Mixed : 74 Empty block comment : 0 Empty : 1110 To Do : 4Number of files read : 111----------------------------D:\\NodeJs\\tieba-crawlernode json爬贴吧小说用的爬虫爬了大概 400 多个支持选取某个贴吧、收藏夹、单个帖子123456789101112131415---------- Result ------------ Physical : 717 Source : 624 Comment : 40 Single-line comment : 40 Block comment : 0 Mixed : 21 Empty block comment : 0 Empty : 74 To Do : 2Number of files read : 9----------------------------D:\\NodeJs\\年度总结html css javascript最近两天熬夜肝的小作品，第一次没有用 cli、没有查资料 完整地从头到尾配置了一堆构建工具主要就是 总结一下 2018 年干了什么事儿吧越写越多，点子太多了，写不完了（比如我统计了一下 switch 各个游戏的游玩时长…认识了哪些朋友…聊天记录多少 MB…之类的无聊的（大概无聊吧？）数据吧）比如 这篇博文的代码行数，我其实是又生成了一遍 json，然后引用在页面里的123456789101112131415---------- Result ------------ Physical : 867 Source : 713 Comment : 88 Single-line comment : 75 Block comment : 13 Mixed : 10 Empty block comment : 0 Empty : 76 To Do : 0Number of files read : 19----------------------------D:\\NodeJs\\RSSHub\\routes\\universities\\nuistnode12 月写的 RSSHub 的南信大 rss，目前自己在用，很爽目前可以获取南信大 8 个站的通知信息，涵盖研究生、计软院、教务处啊 blablablab…然后我就没有更新了…1234567891011121314151617PS D:\\NodeJs\\RSSHub\\routes\\universities\\nuist&gt; sloc ./---------- Result ------------ Physical : 524 Source : 465 Comment : 8 Single-line comment : 8 Block comment : 0 Mixed : 8 Empty block comment : 0 Empty : 59 To Do : 0Number of files read : 8----------------------------C:\\Users\\gylid\\Desktop\\ATMjava fxml第二个 java 课设，共含 11 个 Task（用到什么数据库、序列反序列化、Socket）感谢小越越教我 socket相比第一个课设，这次用 JavaFX 明显熟练多了用上了更加扁平的 UI 设计（其实就是在各种颜色、位置、大小上纠结了很多细节）然而查课设的老师并不看 UI（但是最后我还是软磨硬泡给他秀了一波界面，给我打了 95 分）1234567891011121314151617C:\\Users\\gylid\\Desktop\\ATM&gt; sloc ./---------- Result ------------ Physical : 15936 Source : 12845 Comment : 1707 Single-line comment : 276 Block comment : 1431 Mixed : 82 Empty block comment : 0 Empty : 1466 To Do : 18Number of files read : 210----------------------------E:\\Web 作品\\zxxy-indexhtml css javascript暑假写的某产品首页(Landing Page)，其实最多只有 1w 行123456789101112131415---------- Result ------------ Physical : 60255 Source : 52030 Comment : 4384 Single-line comment : 1870 Block comment : 2514 Mixed : 207 Empty block comment : 22 Empty : 4070 To Do : 11Number of files read : 136----------------------------E:\\Web 作品\\江苏省气候中心-indexhtml css javascript通宵一天帮一位 16 级学长写过的一个小 demo，很粗糙123456789101112131415---------- Result ------------ Physical : 995 Source : 652 Comment : 233 Single-line comment : 0 Block comment : 233 Mixed : 30 Empty block comment : 6 Empty : 146 To Do : 0Number of files read : 4----------------------------E:\\Web 作品\\Duohuo-libraryhtml css javascript已经退出的某社团当时想要玻璃房，于是俺就写了个作品用了 IOS11 App Store 的设计，卡片式布局，比较满意的作品当初熬夜了几天，好像也通宵了 1 天来着，记不得了123456789101112131415---------- Result ------------ Physical : 28394 Source : 23273 Comment : 1954 Single-line comment : 433 Block comment : 1521 Mixed : 154 Empty block comment : 2 Empty : 3323 To Do : 4Number of files read : 16----------------------------D:\\部署在线上的网站\\LunTrans-Docshtml css javascript一个被图书馆老师咕咕咕（其实我也懒得写）的网站的前端写了一点点就没有再动了感谢另一位学长~不好意思 qwq1234567891011121314151617PS D:\\部署在线上的网站\\LunTrans-Docs&gt; sloc ./---------- Result ------------ Physical : 1778 Source : 1452 Comment : 114 Single-line comment : 88 Block comment : 26 Mixed : 18 Empty block comment : 0 Empty : 230 To Do : 4Number of files read : 16----------------------------D:\\NodeJs\\1111prizejavascript双十一抽奖抽了个 AD 钙给 √√123456789101112131415---------- Result ------------ Physical : 14 Source : 14 Comment : 0 Single-line comment : 0 Block comment : 0 Mixed : 0 Empty block comment : 0 Empty : 0 To Do : 0Number of files read : 1----------------------------E:\\Web 作品\\抽奖程序html javascript现场给消防队写的抽奖程序其实就是拿 bootstrap 写的一个单页1234567891011121314151617PS E:\\Web作品\\抽奖程序&gt; sloc ./---------- Result ------------ Physical : 83 Source : 68 Comment : 8 Single-line comment : 1 Block comment : 7 Mixed : 2 Empty block comment : 0 Empty : 9 To Do : 0Number of files read : 3----------------------------C:\\Users\\gylid\\IdeaProjects\\使用 JavaFX 的 Hotel 项目java fxml第一枚课设，用了很多心思，看了几个 YouTube 视频，翻了一堆 Stack Overflow国内教程实在太少了，用 JavaFX 的人就够少了，就更别说这款 UI 框架了就当是菜鸡当一回先驱者吧（掉包小子妄称先驱者），有待开源~1234567891011121314151617PS C:\\Users\\gylid\\IdeaProjects\\使用JavaFX的Hotel项目&gt; sloc ./---------- Result ------------ Physical : 3317 Source : 2783 Comment : 311 Single-line comment : 77 Block comment : 234 Mixed : 39 Empty block comment : 0 Empty : 262 To Do : 3Number of files read : 31----------------------------E:\\Web 作品\\nuistodaywxml wxss javascript学微信小程序的时候练手的小作品，代码最多也就 1w 行123456789101112131415---------- Result ------------ Physical : 19320 Source : 19145 Comment : 151 Single-line comment : 82 Block comment : 69 Mixed : 14 Empty block comment : 0 Empty : 38 To Do : 0Number of files read : 13----------------------------D:\\NodeJs\\node-crawler\\codepenCodepen 备份用的爬虫，一口气备份了上万个 pens（包括我 love 过的、fork 过的、还有 collection 中的）的源代码和封面图_small.jpg有待开源有待获取每个 pen 的详细 json 信息123456789101112131415---------- Result ------------ Physical : 249 Source : 154 Comment : 77 Single-line comment : 28 Block comment : 49 Mixed : 14 Empty block comment : 5 Empty : 37 To Do : 4Number of files read : 3----------------------------总结（阉割版）前端嘛，网页的话过万行还是非常容易的……2018 年是熬夜的一年，经常肝到一两点…也去过医院查过锁骨（其实是过度劳累+着凉了，但是当时是被吓到了，总觉得脖子被人勒住，那两晚都没睡好觉，）进步还是非常明显的，笔记现在已经 2315 篇了（搜集文章、汇集文档、总结语法、记录踩坑、博文备份…），一年学到了很多新技术新知识很多事情啊，就是敢做和不敢做、想做和不想做 的区别大概就是这样子吧，一个高兴又痛苦的一年希望 19 年自己自控力能上来，就像很强的行动力一样！！！首先要从作息做起…不能昼夜颠倒…早起早睡….(๑•̀ㅂ•́)و✧然后就是在校基础课程…… 努力学好吧，新学期新的开始然后… 我想想啊，我好像空间说说数目、分布 还没有统计，我先去爬一下看看然后就是设计啊、深度学习啊 希望 19 年能更多接触更多地学习吧，虽然我是铁定了想当前端（大前端那种），但是一些必要的东西还是要学学滴，拿来装逼当然也是再好不过的其实我是打算 1 号就把 年度总结的网页写完发出来来着，结果还是没写完（而且还有好多没写），等我写完了再放出来的时候估计只能说，“这是我 戊戌年 的年度总结” 了吧（至于为什么要写年度总结这个玩意儿，首先是看隔壁群还有 v2ex 一堆大佬写总结 就跟风，然后就是想养成个习惯吧，插入到个人主页里面（这是我第一年想这么干），以史为鉴，记录年年的数据。总之只有好处没有坏处就是了。","link":"/TjdXkc/"},{"title":"总结CSS水平垂直居中的各种骚操作","text":"CSS 是世界上最难的语言! #（手动滑稽）​ ———— 啊哈呵嗨水平居中NameTagmargin:0 auto;基础, 常用利用 inline-block基础, 常用width:fit-content;CSS3width:fill-available;CSS3垂直居中NameTagpadding上下相等基础, 常用line-height基础, 常用CSS 表(table)布局 👍常用“精灵元素”，利用伪类实现 👍奇技淫巧水平垂直居中NameTag“完全居中法” 👍基础, 常用margin 负值法基础, 常用translate 负值50%变换CSS3, 常用CSS3 flex(弹性)布局 👍CSS3, 常用vw vh和translate 👍CSS3通过JavaScript代码实现居中JavaScript通过隐藏节点+float利用CSS3 grid(网格)布局CSS3object-fit和object-postion居中奇技淫巧水平居中margin:0 auto可以说是极为常用了通过把 固定宽度块级元素 的 margin-left 和 margin-right 设成 auto，就可以使块级元素水平居中。123456789101112.box { width: 300px; height: 300px; border: 3px solid red; /*text-align: center;*/}img { display: block; width: 100px; height: 100px; margin: 0 auto; //关键的一句话}123&lt;div class=\"box\"&gt; &lt;img src=\"img1.jpg\" alt=\"这是一张图片\" /&gt;&lt;/div&gt;⚠️ 注意事项前提是不受 float 影响利用 inline-block利用 text-align: center 可以实现在块级元素内部的内联元素水平居中。此方法对 内联元素(inline), 内联块(inline-block), 内联表(inline-table), inline-flex 元素 水平居中都有效。如果一行中有两个或两个以上的块级元素，可将元素的 display 属性设置为 inline-block，并把父元素的 text-align 属性设置为 center：123.parent { text-align: center;}1234567/*多个子元素时*/.container { text-align: center;}.inline-block { display: inline-block;}width:fit-contentwidth:fit-content 也是应该比较好理解的，“shrink-to-fit”表现，换句话说，和 CSS2.1 中的 float, absolute, inline-block 的尺寸收缩表现是一样的OK，然后，有小伙伴会疑问，既然跟很多 CSS 声明有一样的表现，那为什么还要再弄个新东西呢？就拿水平居中效果举例，首先浮动肯定不行，因为只有左浮动和右浮动；绝对定位压根不占据空间，普通流中根本无法应用，而 inline-block 需要父级使用 text-align:center，而本身可能还需要 text-align:left 略烦。而 width:fit-content 可以没有这些烦恼，因为，width:fit-content 可以实现元素收缩效果的同时，保持原本的元素 block 水平状态，于是，就可以直接使用 margin:auto 实现元素向内自适应同时的居中效果了。12345678910111213141516.box { background-color: #f0f3f9; padding: 10px; /* 这里左右方向是auto */ margin: 10px auto 20px; overflow: hidden;}.inline-block { display: inline-block;}.fit-content { width: -webkit-fit-content; width: -moz-fit-content; width: fit-content;}1234567891011&lt;strong&gt;display:inline-block;&lt;/strong&gt;&lt;div class=\"box inline-block\"&gt; &lt;img src=\"mm1.jpg\" /&gt; &lt;p&gt;display:inline-block居中要靠父元素，而width:fit-content直接margin:auto.&lt;/p&gt;&lt;/div&gt;&lt;strong&gt;width: fit-content;&lt;/strong&gt;&lt;div class=\"box fit-content\"&gt; &lt;img src=\"mm1.jpg\" /&gt; &lt;p&gt;display:inline-block居中要靠父元素，而width:fit-content直接margin:auto.&lt;/p&gt;&lt;/div&gt;解释“fit-content”是 CSS3 中给“width”属性新加的一个属性值，它配合 margin 可以很轻松实现水平居中的效果width:fill-availablewidth:fill-available 比较好理解，比方说，我们在页面中扔一个没有其他样式的元素，则，此时，该元素的 width 表现就是 fill-available，自动填满剩余的空间。也就是我们平常所说的盒模型的 margin,border,padding 的尺寸填充。出现 fill-available 关键字值的价值在于，我们可以让元素的 100%自动填充特性不仅仅在 block 水平元素上，其他元素，例如，我们一直认为的包裹收缩的 inline-block 元素上：1234div { display: inline-block; width: fill-available;}此时，元素兼具了块状元素的自动填充特性以及内联元素的定位对齐等特性(vertical-align/height/line-height)。于是，（例如）我们就可以直接使用 line-height 让一个块状表现的元素垂直居中垂直居中padding 上下相等最基础的方法，只需添加等值的 padding-top 和 padding-bottom 就可以实现垂直居中（margin也行）1234.ct { padding: 40px 0; /*text-align: center;*/}1234&lt;div class=\"ct\"&gt; &lt;p&gt;这里是文字&lt;/p&gt; &lt;img src=\"img1.jpg\" alt=\"这里是图片\" /&gt;&lt;/div&gt;line-height最简单的一种使 单行内联(inline-)元素（单行文字） 垂直居中的方法如果因为某些原因我们不能使用 padding 属性来实现垂直居中，而且已知文本不会换行，那么就可以让 line-height(行高) 和 height(高度) 相等，从而实现垂直居中：1234#v-box { height: 120px; line-height: 120px;}CSS 表(table)布局 👍总的说来这可能是最好的居中实现方法，因为内容块高度会随着实际内容的高度变化，浏览器对此的兼容性也好。最大的缺点是需要大量额外的 html 标签，需要 2~3 层元素让最内层的元素居中。利用表布局的 vertical-align: middle 可以轻松实现子元素的垂直居中1234567891011.center-table { display: table;}.v-cell { /*让元素渲染为表格单元格*/ display: table-cell; /*设置文本水平居中*/ text-align: center; /*设置文本垂直居中*/ vertical-align: middle;}解释CSS 中的确是有 vertical-align 属性，但是它只对(X)HTML 元素中拥有 valign 特性的元素才生效，例如表格元素中 的&lt;td&gt;、&lt;th&gt;、&lt;caption&gt;等，而像&lt;div&gt;、&lt;span&gt;这样的元素是 没有 valign 特性的，因此使用 vertical-align 对它们不起作用但是在 CSS 中还有一个 display 属性能够模拟&lt;table&gt;，所以我们可以使用这个属性来让 &lt;div&gt; 模拟 &lt;table&gt; 就可以使用 vertical-align 了。注意，display:table 和 display:table-cell 的使用方法，前者必须设置在父元素 上，后者必须设置在子元素上，因此我们要为需要定位的文本再增加一个 &lt;div&gt; 元素“精灵元素”，:before 和 display:inline-block 👍利用 “精灵元素”(ghost element) 实现垂直居中，即 通过伪类:before 在父容器内增加新元素后在用 display:inline-block，通过 100%高度的处理让文本和伪元素垂直对齐,从而得到想要的效果。有点 CSS Hack 的骚味123456789101112.container { text-align: center;}.container:before { content: \"\"; display: inline-block; height: 100%; vertical-align: middle;}.inner { display: inline-block;}123&lt;div class=\"container\"&gt; &lt;div class=\"inner\"&gt;this is a box fixed in center of screen&lt;br /&gt;The second line&lt;/div&gt;&lt;/div&gt;解释这个方案是比较特别一些，不是很好理解。首先，.container 水平居中没问题。接着，给.container 伪类:before 设定为 height:100%，这样可以用一个伪元素在.container 获得与父元素等高的空间。然后用 inline-block 和 vertical-align: middle 改变对齐的基线。通过:before 之后，.container 内的行级元素的对齐基线就跑到居中的位置，也就实现了垂直居中对齐。这个时候，如果里面仅一排文字，其实可以不用.inner，但是上面的例子里面有一个，这就不一样了。如果直接把文字放在.container 里面，之前的文字会基于:before 基线，会保持垂直对齐的状态。但是之后的文字会另起一行，这一行将起始于:before 的下一行，所以会在:before 的 100%高度下面，导致被顶出.container。但是如果把文字放在.inner 里面，再让.inner 为 inline-block，就可以使.inner 和:before 处于同一基线，这样就让整个.inner 处于垂直中的状态。强大的 writing-mode我们应该都是这样的的，传统的 web 流中，margin 设置 auto 值的时候，只有水平方向才会居中，因为默认 width 是 100%自适应的，auto 才有计算值可依，而垂直方向，height 没有任何设置的时候高度绝不会自动和父级高度一致，因此，auto 没有计算空间，于是无法实现垂直居中。但是，在 writing-mode 的世界里，纵横规则已经改变，元素的行为表现发生了翻天覆地的变化。1234567891011121314151617.box { width: 400px; height: 300px; background-color: #f0f3f9; overflow: hidden;}.auto { display: block; margin-top: auto; margin-bottom: auto;}.verticle-mode { writing-mode: tb-rl; -webkit-writing-mode: vertical-rl; writing-mode: vertical-rl;}123456789&lt;p&gt;&lt;strong&gt;默认流-margin-top:auto;margin-bottom:auto不居中&lt;/strong&gt;&lt;/p&gt;&lt;div class=\"box\"&gt; &lt;div class=\"auto\"&gt;div块状元素&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;垂直流-margin-top:auto;margin-bottom:auto垂直居中&lt;/strong&gt;&lt;/p&gt;&lt;div class=\"box verticle-mode\"&gt; &lt;div class=\"auto\"&gt;div块状元素&lt;/div&gt;&lt;/div&gt;具有如下优点的水平垂直居中效果：上下左右居中纯 css 实现无定位居中元素不需要设置宽高适应性超强兼容 ie8demo 地址为：https://liyongleihf2006.github.io/center-box/水平垂直居中“完全居中法” 👍绝对定位 + 0 + margin:auto 组合使用，简单粗暴当我们要制作一个 modal dialog 弹出框时，比如弹出居中于屏幕的广告或登录框。这个时候可以考虑一些相对于窗口或网页居中的方案。1234567891011/*.center-container { position: relative;}*/.absolute-center { position: absolute; /*或者fixed，记得要设置z-index*/ top: 0; right: 0; bottom: 0; left: 0; margin: auto;}margin 负值法适用于 固定宽高的块级元素这或许是当前最流行的使用方法。如果块元素尺寸已知，可以通过以下方式让内容块居中于容器显示：外边距 margin 取负数，大小为 width/height（不使用 box-sizing: border-box 时还包括 padding）的一半，再加上 top: 50%; left: 50%;1234567891011121314/*.parent { position: relative;}*/.child { top: 50%; width: 100px; height: 100px; margin-top: -50px; /* margin-top值为自身高度的一半 */ margin-left: -50px; position: absolute; padding: 0;}position:absolute、50%和 translate 👍利用 CSS3 translate 的 2D 变换，在水平和垂直两个方向都向反向平移宽高的一半，从而使元素 水平垂直居中。若只是水平居中，请使用 translateX(-50%)若只是垂直居中，请使用 translateY(-50%)12345678910.ele { /*设置元素绝对定位*/ position: absolute; /*top 50%*/ top: 50%; /*left 50%*/ left: 50%; /*css3 transform 实现*/ transform: translate(-50%, -50%);}CSS3 flex(弹性)布局 👍多个块状元素解决方案，简单粗暴只需把待处理的块状元素的父元素添加属性 display:flex 及 justify-content:center 即可:12345678910.flex-center { /*弹性盒模型*/ display: flex; /*垂直方向排布*/ /*flex-direction: column;*/ /*主轴居中对齐*/ justify-content: center; /*侧轴居中对齐*/ align-items: center;}解释简单解释一下，当 display:flex 时，表示该容器内部的元素将按照 flex 进行布局。其中 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而 align-items 属性定义 flex 子项在 flex 容器的当前行的侧轴（纵轴）方向上的对齐方式。对.container 赋予了这些样式之后，作为它的内部元素.inner 自己自觉的居中了。而且这里你会发现，由于没有使用 text-align:center，.inner 里面的文字是不会居中的，也就是说仅仅.inner 这个容器居中而已。⚠️ 注意事项Flexbox 是 CSS3 新增属性，设计初衷是为了解决像垂直居中这样的常见布局问题。记住 Flexbox 不只是用于居中，也可以分栏或者解决一些令人抓狂的布局问题。但是会存在浏览器的兼容问题。vw vh 和 translate 👍vh 和 vw 是 CSS3 新增的单位，是指“viewport 的 height 和 width 的 1%”比如说 50vh 就是当前视口（窗口的高度，实验中包含了滚动条）高度的 50%。也就是说 vw 将获得和 1%差不多的 window 宽度。因此用在 fixed 的时候更加适合。123456.inner { position: fixed; top: 50vh; left: 50vw; transform: translate(-50%, -50%);}123&lt;div class=\"inner\"&gt; this is a box fixed in center of screen&lt;/div&gt;其实和使用 50%没有太大的差别，因为这时 top、left 取的 50%是相对于父元素的，和 margin、padding 不一样。如果非得要 margin 的话，就可以从这里衍生出变体：1234567.inner2 { position: fixed; top: 0; left: 0; margin: 50vh 0 0 50vw; transform: translate(-50%, -50%);}vh vw 只能从窗口的大小去考虑，不适合正常的文本流。不过有的时候可以非常有用，特别是在做全屏应用的时候，比如 full page。通过 JavaScript 代码实现居中原生 js 实现123456div { padding: 50px; display: inline-block; background-color: pink; position: absolute;}12345window.onload = function() { var div = document.querySelector(\"div\"); // 获取元素 div.style.left = (window.innerWidth - div.offsetWidth) / 2 + \"px\"; // 设置left div.style.top = (window.innerHeight - div.offsetHeight) / 2 + \"px\"; // 设置top};jQuery 实现水平和垂直居中jQuery 实现水平和垂直居中的原理就是通过 jQuery 设置 DIV 的 CSS，获取 DIV 的左、上的边距偏移量，边距偏移量的算法就是用页面窗口的宽度减去该 DIV 得宽度，得到的值再除以 2 即左偏移量，右偏移量算法相同。注意 DIV 的 CSS 设置要在 resize() 方法中完成，就是每次改变窗口大小时，都要执行设置 DIV 的 CSS，代码如下：1234567$(window).resize(function() { $(\".mydiv\").css({ position: \"absolute\", left: ($(window).width() - $(\".mydiv\").outerWidth()) / 2, top: ($(window).height() - $(\".mydiv\").outerHeight()) / 2 });});此外在页面载入时，就需要调用 resize()。123$(function() { $(window).resize();});此方法的好处就是不需要知道 DIV 的具体宽度和高度大小，直接用 jQuery 就可以实现水平和垂直居中，而且兼容各浏览器，这个方法在很多的弹出层效果中应用。通过隐藏节点+float我们可以通过增加一个隐藏节点，然后使其float:left，这样子元素就会被隐藏节点推着水平居中。这种增加隐藏节点方法也适用于 CSS 垂直居中，原理一样，但是不用 float。利用 CSS3 grid(网格)布局利用 grid 实现水平垂直居中，CSS3 的最新技术，但兼容性较差，生产环境中不推荐。12345678.parent { height: 140px; display: grid;}.child { margin: auto;}object-fit 和 object-postion 居中object-fit 只能用于可替换元素(replaced element) ，用以指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。一般用做图片的样式。它有着类似 background-image 的用法：1234.center { object-fit: fill|cover|contain|none|scale-down; /*其属性值，分别是填充（默认）、包含、覆盖（可能被裁剪）、无变化（保持原状）和等比例缩放*/}而 object-positon 属性默认值是50% 50%，也就是居中(也就是要求居中的情况不用写这个属性了……），对元素定位控制，类似 background-postion。空标签无形中添加了空标签，所以不建议使用1234567891011121314151617181920.wrap { width: 400px; height: 400px; background: #fcf; /*行高等于高度,垂直居中*/ line-height: 400px; /*水平居中*/ text-align: center;}.wrap img { /* 图片按道理需要设置display：block，在这边条件的限制，所以我们没有设置了 */ /* display: block; */ width: 200px; height: 200px; /*垂直居中*/ vertical-align: middle;}.wrap span { display: inline-block;}1234&lt;div class=\"wrap\"&gt; &lt;img src=\"Koala.jpg\" alt=\"\" title=\"\" /&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;注意：添加了 span 标签，并且设置 display 属性设置为 inline-block 来使我们 span 标签拥有”layout”，这样就解决了在 IE6 不能兼容的问题.123456789101112131415161718192021html,body { height: 100%;}.box { position: relative; /*清除浮动*/ clear: both; height: 300px; width: 300px; margin: 0 auto; background: #999;}.floater { float: left; /*相对于父元素高度的50%*/ height: 50%; /*居中元素高度的一半*/ margin-bottom: -150px; background: #fcf;}网易 NEC 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div class=\"floater\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt; 独行冰海、梦幻雪冰&lt;/div&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;HTML5Course - HTML5学堂&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"reset.css\" /&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.8.3.min.js\"&gt;&lt;/script&gt; &lt;style&gt; html, body { width: 100%; height: 100%; } .wrap { position: relative; width: 100%; height: 100%; } .wrap &gt; div { /*父级设置定位*/ position: absolute; left: 50%; top: 50%; } .wrap img { /*设置图片大小*/ display: block; width: 200px; height: 200px; } .wrap img:nth-child(1) { /*第一张图片隐藏*/ visibility: hidden; } .wrap img:nth-child(2) { /*第二张图片定位*/ position: absolute; left: -50%; top: -50%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;div&gt; &lt;img src=\"https://mmbiz.qlogo.cn/mmbiz/p6DwiaCENIB6pR8GhsfVeo7382t1SicdA8iahVpBPSRMaFPaHHLXuyXvkryL43R4GuLMOrhVvDFwwfprmH9f9EgVg/0?wx_fmt=jpeg\" alt=\"HTML5学堂\" /&gt; &lt;img src=\"https://mmbiz.qlogo.cn/mmbiz/p6DwiaCENIB6pR8GhsfVeo7382t1SicdA8iahVpBPSRMaFPaHHLXuyXvkryL43R4GuLMOrhVvDFwwfprmH9f9EgVg/0?wx_fmt=jpeg\" alt=\"HTML5学堂\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;效果分析它的父级 div 设置 left、top 各自为 50%，这一步相信大家还是可以理解，就不详细做介绍了。那么为什么要用两张图片？大家仔细看看，该方法是没有给父级设置宽高，是靠图片来撑开，所以有一张图片是撑开父级的宽高。另外一张图片设置 left、top 为 50%，意思就是相对它的父级定位，left、top 都是父级宽高的一半（父级的宽高等于图片的宽高）效果原理分析这种方法的优势优点是可以不知道图片的大小，随便放张尺寸上去都能做到居中。另外，兼容性好，如果是不使用 nth-child 选择器的话，IE6 都能兼容的calc()居中12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;HTML5Course - HTML5学堂 - 利用CSS3的calc( )实现水平垂直居中&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"reset.css\" /&gt; &lt;style&gt; .wrap { width: 400px; height: 400px; background-color: #ccc; } .wrap .con { /*利用CSS3的calc() ，它的用法类似于函数，能够给元素设置动态的值：*/ /*（父级的宽度 - 自身的宽度）的一半当做padding的值*/ padding: -webkit-calc((100% - 100px) / 2); padding: -moz-calc((100% - 100px) / 2); padding: -ms-calc((100% - 100px) / 2); padding: calc((100% - 100px) / 2); width: 100px; height: 100px; background-color: pink; color: #fff; /*背景只显示内容区域*/ background-clip: content-box; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"con\"&gt;HTML5学堂 - 刘国利、陈能堡&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;calc()属于 CSS3，用于动态计算长度值，可以用在任何一个需要的地方。有了 calc()，你可以通过计算来决定一个对象的大小和形状。还可以在一个 calc()内部嵌套另一个 calc()。妈妈再也不担心我水平垂直居中不了了。","link":"/yMZpWN/"}],"tags":[{"name":"awesome","slug":"awesome","link":"/tags/awesome/"},{"name":"RESTful API","slug":"RESTful-API","link":"/tags/RESTful-API/"},{"name":"参考文献","slug":"参考文献","link":"/tags/参考文献/"},{"name":"推荐","slug":"推荐","link":"/tags/推荐/"},{"name":"教程","slug":"教程","link":"/tags/教程/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客","slug":"博客","link":"/tags/博客/"},{"name":"图床","slug":"图床","link":"/tags/图床/"},{"name":"坑","slug":"坑","link":"/tags/坑/"},{"name":"解决方法","slug":"解决方法","link":"/tags/解决方法/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"},{"name":"代码片段","slug":"代码片段","link":"/tags/代码片段/"},{"name":"最大公约数","slug":"最大公约数","link":"/tags/最大公约数/"},{"name":"密码学","slug":"密码学","link":"/tags/密码学/"},{"name":"文件校验","slug":"文件校验","link":"/tags/文件校验/"},{"name":"扫盲","slug":"扫盲","link":"/tags/扫盲/"},{"name":"CSS动画","slug":"CSS动画","link":"/tags/CSS动画/"},{"name":"歌单","slug":"歌单","link":"/tags/歌单/"},{"name":"Splatoon","slug":"Splatoon","link":"/tags/Splatoon/"},{"name":"Nintendo Switch","slug":"Nintendo-Switch","link":"/tags/Nintendo-Switch/"},{"name":"插件","slug":"插件","link":"/tags/插件/"},{"name":"CSS选择器","slug":"CSS选择器","link":"/tags/CSS选择器/"},{"name":"cheatsheet","slug":"cheatsheet","link":"/tags/cheatsheet/"},{"name":"年度总结","slug":"年度总结","link":"/tags/年度总结/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/后端/"},{"name":"技术宅","slug":"技术宅","link":"/categories/技术宅/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"游戏","slug":"游戏","link":"/categories/游戏/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"生活","slug":"生活","link":"/categories/生活/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/前端/CSS/"},{"name":"音乐","slug":"生活/音乐","link":"/categories/生活/音乐/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/前端/JavaScript/"},{"name":"年度总结","slug":"生活/年度总结","link":"/categories/生活/年度总结/"}]}